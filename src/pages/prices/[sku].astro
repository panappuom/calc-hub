---
import "../../styles/global.css";
import Footer from "../../components/Footer.astro";
import skus from "../../data/skus.json";
import { safeBreak } from "../../lib/safe-break";
const IS_DEV = import.meta.env.DEV;
const BASE_URL = import.meta.env.BASE_URL;
const clientGlobalsScript = `window.__APP_DEV__ = ${JSON.stringify(IS_DEV)};\nwindow.__BASE_URL__ = ${JSON.stringify(BASE_URL)};`;

let data;
let rakutenData;
let yahooData;
try {
  const url = new URL(
    BASE_URL + "data/prices/today.json",
    Astro.site
  );
  const res = await fetch(url);
  if (res.ok) {
    data = await res.json();
  }
} catch {}
try {
  const url = new URL(
    BASE_URL + "data/prices/today.rakuten.json",
    Astro.site
  );
  const res = await fetch(url);
  if (res.ok) {
    rakutenData = await res.json();
  }
} catch {}
try {
  const url = new URL(
    BASE_URL + "data/prices/today.yahoo.json",
    Astro.site
  );
  const res = await fetch(url);
  if (res.ok) {
    yahooData = await res.json();
  }
} catch {}
const { sku } = Astro.params;
const skuInfo = skus.find(s => s.id === sku);
const priceInfo = data?.items?.find(i => i.skuId === sku);
function getEffectivePriceValue(it) {
  const price = Number(it?.price);
  if (!Number.isFinite(price)) {
    return Number.POSITIVE_INFINITY;
  }
  const pointRate = Number(it?.pointRate ?? 0);
  if (!Number.isFinite(pointRate) || pointRate <= 0) {
    return Math.floor(price);
  }
  return Math.floor(price * (100 - pointRate) / 100);
}

function withEffectivePrice(it) {
  return {
    ...it,
    effective: getEffectivePriceValue(it)
  };
}

function getEffectiveValue(it) {
  if (!it) return Number.NaN;
  const effective = Number(it.effective);
  if (Number.isFinite(effective)) {
    return effective;
  }
  const fallback = getEffectivePriceValue(it);
  return Number.isFinite(fallback) ? fallback : Number.NaN;
}

function normalizeShopName(name) {
  if (typeof name !== 'string') return '';
  return name
    .toLowerCase()
    .replace(/[(（][^)）]*[)）]/g, '')
    .replace(/\s+/g, '')
    .replace(/[【】\[\]]/g, '')
    .replace(/店$/g, '')
    .trim();
}

function equalsByPriceShop(a, b) {
  if (!a || !b) return false;
  const priceA = Number(a.price);
  const priceB = Number(b.price);
  if (!Number.isFinite(priceA) || !Number.isFinite(priceB)) {
    return false;
  }
  const samePrice = priceA === priceB;
  if (!samePrice) {
    return false;
  }
  const shopIdA = a.shopId != null ? String(a.shopId) : '';
  const shopIdB = b.shopId != null ? String(b.shopId) : '';
  if (shopIdA && shopIdB) {
    return shopIdA === shopIdB;
  }
  const shopNameA = normalizeShopName(a.shopName);
  const shopNameB = normalizeShopName(b.shopName);
  return Boolean(shopNameA) && shopNameA === shopNameB;
}

const list = priceInfo?.list ? priceInfo.list.map(withEffectivePrice).sort((a, b) => a.effective - b.effective) : [];
const rakutenSource = rakutenData?.items?.find(i => i.skuId === sku)?.list ?? [];
const yahooSource = yahooData?.items?.find(i => i.skuId === sku)?.list ?? [];
const rakutenList = rakutenSource.map(withEffectivePrice).sort((a, b) => a.effective - b.effective);
const yahooList = yahooSource.map(withEffectivePrice).sort((a, b) => a.effective - b.effective);
const allList = [
  ...rakutenList.map(it => ({ ...it, store: '楽天' })),
  ...yahooList.map(it => ({ ...it, store: 'Yahoo' }))
].sort((a, b) => a.effective - b.effective);
const hasAllPoints = allList.some(it => Number(it.pointRate) > 0);
const sections = [
  { name: '楽天', key: 'rakuten', list: rakutenList, status: data?.sourceStatus?.rakuten ?? 'fail', hasPoints: rakutenList.some(it => Number(it.pointRate) > 0) },
  { name: 'Yahoo', key: 'yahoo', list: yahooList, status: data?.sourceStatus?.yahoo ?? 'fail', hasPoints: yahooList.some(it => Number(it.pointRate) > 0) }
];
const statusMessages = {
  partial: 'このソースの一部データが取得できませんでした。表示は最新の取得分です。',
  fail: 'このソースの取得に失敗しました。別ソースまたは前回データで表示しています。'
};
const bestToday = allList.length
  ? allList[0]
  : (list.length ? list.reduce((min, it) => (it.effective < min.effective ? it : min), list[0]) : null);
let bestRecommended = priceInfo?.bestRecommended ?? null;
let bestRecommendedEvidence = typeof priceInfo?.bestRecommendedEvidence === 'string'
  ? priceInfo.bestRecommendedEvidence
  : null;
if (!bestRecommended && list.length && skuInfo?.brandHints?.length) {
  const cand = list.filter(it => {
    const title = it.title?.toLowerCase() ?? '';
    return skuInfo.brandHints.some(b => title.includes(b.toLowerCase()));
  });
  if (cand.length) {
    bestRecommended = cand.reduce((min, it) => (it.effective < min.effective ? it : min), cand[0]);
    bestRecommendedEvidence = 'ブランド一致OK';
  }
}
if (bestRecommended) {
  bestRecommended = { ...bestRecommended, effective: Number.isFinite(bestRecommended.effective) ? bestRecommended.effective : getEffectivePriceValue(bestRecommended) };
  if (!bestRecommendedEvidence) {
    const candEvidence =
      typeof bestRecommended.reason === 'string'
        ? bestRecommended.reason
        : typeof bestRecommended.note === 'string'
          ? bestRecommended.note
          : null;
    if (candEvidence) {
      bestRecommendedEvidence = candEvidence;
    }
  }
}
const bestTodayCard = getPriceCardModel(bestToday, { prefix: '最安' });
const bestRecommendedCard = getPriceCardModel(bestRecommended, { prefix: '推奨' });

const hasRecommendedSection = Boolean(skuInfo?.brandHints?.length);
const bestTodayEffectiveValue = getEffectiveValue(bestToday);
const bestRecommendedEffectiveValue = getEffectiveValue(bestRecommended);
const isSamePrice =
  Number.isFinite(bestTodayEffectiveValue) &&
  Number.isFinite(bestRecommendedEffectiveValue) &&
  bestTodayEffectiveValue === bestRecommendedEffectiveValue;
const isSameOffer = bestToday && bestRecommended ? equalsByPriceShop(bestToday, bestRecommended) : false;
const bestPriceCase = hasRecommendedSection && bestTodayCard && bestRecommendedCard && isSamePrice
  ? (isSameOffer ? 'merge' : 'tie')
  : 'separate';
const tieSourceList = allList.length ? allList : list;
const tieCount = Number.isFinite(bestTodayEffectiveValue)
  ? tieSourceList.filter(it => getEffectiveValue(it) === bestTodayEffectiveValue).length
  : 0;
const shouldShowTieLink = bestPriceCase === 'tie' && tieCount > 1;
const showRecommendedCard = hasRecommendedSection && bestPriceCase === 'separate';

const bestPriceContext = {
  case: bestPriceCase,
  sku,
  price: Number.isFinite(bestTodayEffectiveValue) ? bestTodayEffectiveValue : null,
  shopId: bestToday?.shopId ?? null,
  tieCount,
};
const bestPriceContextScript = JSON.stringify(bestPriceContext);
function formatCurrency(value) {
  const num = Number(value);
  if (!Number.isFinite(num)) return '';
  return `${Math.round(num).toLocaleString('ja-JP')}円`;
}

function formatPrice(it) {
  if (!it) return '';
  return formatCurrency(it.price);
}

function getShopLinkDescription(name) {
  if (!name) {
    return 'ショップで商品の詳細を確認できます（新しいタブで開きます）';
  }
  return `${name}で商品の詳細を確認できます（新しいタブで開きます）`;
}

function truncateShopName(name, maxLength = 20) {
  if (!name) return '';
  if (name.length <= maxLength) {
    return name;
  }
  return `${name.slice(0, maxLength)}…`;
}

function getPriceCardModel(item, { prefix }) {
  if (!item) return null;
  const rawPrice = Number(item.price);
  if (!Number.isFinite(rawPrice) || rawPrice <= 0) {
    return null;
  }

  const effectiveValue = Number.isFinite(item.effective) ? item.effective : getEffectivePriceValue(item);
  const pointRate = Number(item.pointRate ?? 0);
  const priceText = formatCurrency(rawPrice);
  const hasEffectiveLine = Number.isFinite(effectiveValue) && effectiveValue > 0 && effectiveValue !== rawPrice;
  const effectiveText = hasEffectiveLine ? formatCurrency(effectiveValue) : null;

  const resolvedName = item.shopName ?? '';
  const displayNameSource = resolvedName || 'ショップ';

  return {
    hasEffectiveLine,
    prefix,
    primaryValue: hasEffectiveLine ? effectiveText : priceText,
    primaryAriaLabel: hasEffectiveLine ? `実質価格 ${effectiveText}` : `通常価格 ${priceText}`,
    secondaryPrice: priceText,
    secondaryPriceAriaLabel: `通常価格 ${priceText}`,
    hasPoints: hasEffectiveLine && pointRate > 0,
    pointRateText: `${pointRate}%`,
    pointRateAriaLabel: `ポイント還元率 ${pointRate}%`,
    shopName: resolvedName,
    shopDisplayName: truncateShopName(displayNameSource),
    shopTitle: resolvedName || undefined,
    itemUrl: item.itemUrl
  };
}

function getStoreBadgeClass(store) {
  if (store === '楽天') {
    return 'store-badge store-badge--rakuten';
  }
  if (typeof store === 'string' && store.toLowerCase() === 'yahoo') {
    return 'store-badge store-badge--yahoo';
  }
  return 'store-badge';
}

export function getStaticPaths() {
  return skus.map(s => ({ params: { sku: s.id } }));
}
---
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <base href={BASE_URL} />
    <script is:inline set:html={clientGlobalsScript}></script>
    <title>{skuInfo ? skuInfo.q : sku} – 価格一覧</title>
  </head>
<body data-sku={sku}>
    <div class="wrap">
        <a href="./" class="small">← トップ</a>
      <h1 set:html={safeBreak(`${skuInfo ? skuInfo.q : sku} – 価格一覧`)}></h1>
      <p class="jp-copy">ショップ別の価格一覧です。実質価格（ポイント込み）で安い順に並べています。</p>
      <p class="small jp-copy">
        {data
          ? `取得日時: ${new Date(data.updatedAt).toLocaleString('ja-JP')}`
          : 'データ少'}
      </p>
      {skuInfo && (
        <div>
          <h2 set:html={safeBreak("仕様")}></h2>
          <ul>
            {skuInfo.filters && <li>フィルタ: {skuInfo.filters.join(', ')}</li>}
            {skuInfo.brandHints && <li>ブランド候補: {skuInfo.brandHints.join(', ')}</li>}
          </ul>
        </div>
      )}
      {priceInfo ? (
        <>
          <div class="best-price">
            <h2 set:html={safeBreak("最安情報")}></h2>
            <div class="best-price-cards" data-bestprice-case={bestPriceCase}>
              <section class="best-price-card" role="region" aria-labelledby="best-today-heading">
                <p class="best-price-card__label" id="best-today-heading">今日の最安</p>
                {bestPriceCase === 'merge' && (
                  <span class="best-price-card__badge" aria-label="推奨最安と同一のため統合表示">推奨最安と一致</span>
                )}
                {bestTodayCard ? (
                  <>
                    <p class="best-price-card__line best-price-card__line--primary">
                      <span class="best-price-card__value" aria-label={bestTodayCard.primaryAriaLabel}>{bestTodayCard.primaryValue}</span>
                    </p>
                    {bestTodayCard.hasEffectiveLine && (
                      <p class="best-price-card__line best-price-card__line--secondary">
                        <span aria-label={bestTodayCard.secondaryPriceAriaLabel}>通常 {bestTodayCard.secondaryPrice}</span>
                        {bestTodayCard.hasPoints && (
                          <>
                            <span aria-hidden="true"> / </span>
                            <span aria-label={bestTodayCard.pointRateAriaLabel}>ポイント {bestTodayCard.pointRateText}</span>
                          </>
                        )}
                      </p>
                    )}
                    {bestTodayCard.itemUrl && (
                      <p class="best-price-card__line best-price-card__line--link">
                        <a
                          href={bestTodayCard.itemUrl}
                          target="_blank"
                          rel="nofollow noopener"
                          class="best-price-card__link"
                          title={bestTodayCard.shopTitle}
                          aria-label={getShopLinkDescription(bestTodayCard.shopName || bestTodayCard.shopDisplayName)}
                        >
                          {bestTodayCard.shopDisplayName} で確認 <span aria-hidden="true">↗</span>
                        </a>
                      </p>
                    )}
                    {bestPriceCase === 'merge' && bestRecommendedEvidence && (
                      <p class="best-price-card__note">{bestRecommendedEvidence}</p>
                    )}
                    {shouldShowTieLink && (
                      <p class="best-price-card__note best-price-card__note--link">
                        <a
                          href="#price-table-all"
                          class="best-price-card__tie-link"
                          data-bestprice-tie-trigger
                          data-bestprice-tie-effective={String(bestTodayEffectiveValue)}
                        >
                          同額 {tieCount} 件を見る
                        </a>
                      </p>
                    )}
                  </>
                ) : (
                  <p class="best-price-card__line best-price-card__line--empty">データ少</p>
                )}
              </section>
              {showRecommendedCard ? (
                <section class="best-price-card" role="region" aria-labelledby="best-recommended-heading">
                  <p class="best-price-card__label" id="best-recommended-heading">推奨最安（ブランド一致）</p>
                  {bestRecommendedCard ? (
                    <>
                      <p class="best-price-card__line best-price-card__line--primary">
                        <span class="best-price-card__value" aria-label={bestRecommendedCard.primaryAriaLabel}>{bestRecommendedCard.primaryValue}</span>
                      </p>
                      {bestRecommendedCard.hasEffectiveLine && (
                        <p class="best-price-card__line best-price-card__line--secondary">
                          <span aria-label={bestRecommendedCard.secondaryPriceAriaLabel}>通常 {bestRecommendedCard.secondaryPrice}</span>
                          {bestRecommendedCard.hasPoints && (
                            <>
                              <span aria-hidden="true"> / </span>
                              <span aria-label={bestRecommendedCard.pointRateAriaLabel}>ポイント {bestRecommendedCard.pointRateText}</span>
                            </>
                          )}
                        </p>
                      )}
                      {bestRecommendedCard.itemUrl && (
                        <p class="best-price-card__line best-price-card__line--link">
                          <a
                            href={bestRecommendedCard.itemUrl}
                            target="_blank"
                            rel="nofollow noopener"
                            class="best-price-card__link"
                            title={bestRecommendedCard.shopTitle}
                            aria-label={getShopLinkDescription(bestRecommendedCard.shopName || bestRecommendedCard.shopDisplayName)}
                          >
                            {bestRecommendedCard.shopDisplayName} で確認 <span aria-hidden="true">↗</span>
                          </a>
                        </p>
                      )}
                    </>
                  ) : (
                    <p class="best-price-card__line best-price-card__line--empty">該当なし</p>
                  )}
                </section>
              ) : null}
            </div>
          </div>
          <script is:inline set:html={`(function(){
  const context = ${bestPriceContextScript};
  if (!context || typeof window === 'undefined') return;

  function dispatchAnalytics(name, detail) {
    if (!name) return;
    try {
      window.dispatchEvent(new CustomEvent(name, { detail }));
    } catch (error) {
      console.warn('bestprice analytics dispatch failed', { name, error });
    }
    const dataLayer = window.dataLayer;
    if (Array.isArray(dataLayer)) {
      try {
        dataLayer.push({ event: name, detail });
      } catch (error) {
        console.warn('bestprice analytics dataLayer push failed', { name, error });
      }
    }
  }

  if (context.case === 'merge' && context.price != null) {
    dispatchAnalytics('bestprice_merge', {
      sku: context.sku || '',
      price: context.price,
      shopId: context.shopId ?? null,
    });
  } else if (context.case === 'tie' && context.price != null && context.tieCount > 1) {
    dispatchAnalytics('bestprice_tie', {
      sku: context.sku || '',
      price: context.price,
      count: context.tieCount,
    });
  }

  const trigger = document.querySelector('[data-bestprice-tie-trigger]');
  if (!trigger) return;

  const effectiveValue = Number(trigger.dataset.bestpriceTieEffective);
  if (!Number.isFinite(effectiveValue)) return;

  const highlightClass = 'bestprice-tie-highlight';
  const highlightMs = 4000;

  function getRows() {
    const table = document.getElementById('price-table-all');
    if (!table) return [];
    return Array.from(table.querySelectorAll('tbody tr')).filter(row => !row.classList.contains('table-collapse-toggle-row'));
  }

  function clearHighlights() {
    getRows().forEach(row => row.classList.remove(highlightClass));
  }

  function highlightRows() {
    const rows = getRows();
    if (!rows.length) return;

    const matches = rows.filter(row => {
      const value = Number(row.dataset.eff);
      return Number.isFinite(value) && value === effectiveValue;
    });

    if (!matches.length) return;

    const allTabButton = document.querySelector('.tabs button[data-tab="all"]');
    if (allTabButton && !allTabButton.classList.contains('active')) {
      allTabButton.click();
    }

    const first = matches[0];
    clearHighlights();
    matches.forEach(row => row.classList.add(highlightClass));
    first.scrollIntoView({ behavior: 'smooth', block: 'center' });

    window.setTimeout(clearHighlights, highlightMs);
  }

  trigger.addEventListener('click', event => {
    event.preventDefault();
    highlightRows();
  });
})();`}></script>
          <div class="tabs">
            <button type="button" data-tab="all" class="active">全ストア</button>
            <button type="button" data-tab="rakuten">楽天のみ</button>
            <button type="button" data-tab="yahoo">Yahooのみ</button>
          </div>
          <div class="price-section tab-content" data-tab="all">
            <h2 class="sr-only" set:html={safeBreak("全ストア")}></h2>
            {allList.length ? (
              <>
                {hasAllPoints && <button class="sort-toggle">価格順に切替</button>}
                <table class="price-table" id="price-table-all">
                  <thead class="sr-only-mobile">
                    <tr>
                      <th id="col-all-store" scope="col">ストア</th>
                      <th id="col-all-shop" scope="col">ショップ</th>
                      <th id="col-all-price" scope="col" data-column="price">価格</th>
                      <th id="col-all-point" scope="col" data-column="points">ポイント</th>
                      <th id="col-all-eff" scope="col" data-column="effective">実質価格<br/><span class="small">（ポイント込み）</span></th>
                      <th id="col-all-action" scope="col" data-column="action" class="sr-only-mobile">ショップで確認</th>
                    </tr>
                  </thead>
                  <tbody>
                    {allList.map(it => {
                      const eff = Number.isFinite(it.effective) ? it.effective : getEffectivePriceValue(it);
                      const hasPointRate = Number(it.pointRate ?? 0) > 0;
                      return (
                        <tr class="has-store-badge" data-price={it.price} data-eff={eff}>
                          <td
                            headers="col-all-store"
                            data-label="ストア"
                            data-cell="store"
                          >
                            <span class={getStoreBadgeClass(it.store)}>{it.store}</span>
                          </td>
                          <td headers="col-all-shop" data-label="ショップ" data-cell="shop">
                            <span class="sr-only">ショップ</span>
                            <div class="price-card-head">
                              <div class="badges">
                                <span class={getStoreBadgeClass(it.store)}>{it.store}</span>
                              </div>
                              <div class="shop-name" title={it.shopName}>
                                {it.shopName}
                              </div>
                            </div>
                            <span class="shop-name shop-name--desktop" title={it.shopName}>
                              {it.shopName}
                            </span>
                          </td>
                          <td
                            headers="col-all-price"
                            data-label="価格"
                            data-cell="price"
                            class={!hasPointRate ? 'is-muted' : undefined}
                          >
                            {formatPrice(it)}
                          </td>
                          <td headers="col-all-point" data-label="ポイント" data-cell="points">{hasPointRate ? `${it.pointRate}%` : '-'}</td>
                          <td headers="col-all-eff" data-label="実質価格" data-cell="effective">{formatCurrency(eff)}</td>
                          <td
                            headers="col-all-action"
                            data-label="ショップで確認"
                            data-cell="action"
                          >
                            <a
                              class="shop-link-button"
                              href={it.itemUrl}
                              target="_blank"
                              rel="nofollow noopener"
                              title={getShopLinkDescription(it.shopName)}
                              aria-label={getShopLinkDescription(it.shopName)}
                            >
                              ショップで確認
                              <span aria-hidden="true" class="external-link-icon">↗</span>
                            </a>
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </>
            ) : (
              <p>データ少</p>
            )}
          </div>
          {sections.map(sec => (
            <div class="price-section tab-content" data-tab={sec.key} data-source-status={sec.status} style="display:none">
              <h2 class="sr-only" set:html={safeBreak(sec.name)}></h2>
              {sec.status !== 'ok' && (
                <span class="status-icon--warn" aria-label={statusMessages[sec.status]} title={statusMessages[sec.status]}>⚠️</span>
              )}
              {sec.list.length ? (
              <>
                  {sec.hasPoints && <button class="sort-toggle">価格順に切替</button>}
                  <table class="price-table">
                    <thead class="sr-only-mobile">
                      <tr>
                        <th id={`col-${sec.key}-shop`} scope="col">ショップ</th>
                        <th id={`col-${sec.key}-price`} scope="col" data-column="price">価格</th>
                        <th id={`col-${sec.key}-point`} scope="col" data-column="points">ポイント</th>
                        <th id={`col-${sec.key}-eff`} scope="col" data-column="effective">実質価格<br/><span class="small">（ポイント込み）</span></th>
                        <th id={`col-${sec.key}-action`} scope="col" data-column="action" class="sr-only-mobile">ショップで確認</th>
                      </tr>
                    </thead>
                    <tbody>
                      {sec.list.map(it => {
                        const eff = Number.isFinite(it.effective) ? it.effective : getEffectivePriceValue(it);
                        const hasPointRate = Number(it.pointRate ?? 0) > 0;
                        return (
                          <tr data-price={it.price} data-eff={eff}>
                            <td headers={`col-${sec.key}-shop`} data-label="ショップ" data-cell="shop">
                              <span class="sr-only">ショップ</span>
                              <div class="price-card-head">
                                <div class="badges"></div>
                                <div class="shop-name" title={it.shopName}>
                                  {it.shopName}
                                </div>
                              </div>
                              <span class="shop-name shop-name--desktop" title={it.shopName}>
                                {it.shopName}
                              </span>
                            </td>
                            <td
                              headers={`col-${sec.key}-price`}
                              data-label="価格"
                              data-cell="price"
                              class={!hasPointRate ? 'is-muted' : undefined}
                            >
                              {formatPrice(it)}
                            </td>
                            <td headers={`col-${sec.key}-point`} data-label="ポイント" data-cell="points">{hasPointRate ? `${it.pointRate}%` : '-'}</td>
                            <td headers={`col-${sec.key}-eff`} data-label="実質価格" data-cell="effective">{formatCurrency(eff)}</td>
                            <td
                              headers={`col-${sec.key}-action`}
                              data-label="ショップで確認"
                              data-cell="action"
                            >
                              <a
                                class="shop-link-button"
                                href={it.itemUrl}
                                target="_blank"
                                rel="nofollow noopener"
                                title={getShopLinkDescription(it.shopName)}
                                aria-label={getShopLinkDescription(it.shopName)}
                              >
                                ショップで確認
                                <span aria-hidden="true" class="external-link-icon">↗</span>
                              </a>
                            </td>
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                </>
              ) : (
                <p>データ少</p>
              )}
            </div>
          ))}
          <p class="small jp-copy">※実質価格はポイント考慮の試算です。</p>
          <p class="small jp-copy">価格・在庫は常に変動します。購入前にリンク先で最新情報をご確認ください。</p>
          <h2 set:html={safeBreak("価格推移 (30日)")}></h2>
          <div class="chart-container chart-wrap">
            <div id="chart-skeleton" class="chart-skeleton" aria-hidden="true"></div>
            <canvas
              id="chart"
              class="chart"
              data-sku={sku}
              tabindex="0"
              aria-label="過去30日の価格推移。左右キーでポイントを移動できます。"
            ></canvas>
            <div id="chart-tooltip" class="chart-tooltip" role="presentation" aria-hidden="true"></div>
          </div>
          <div class="chart-summary chips" aria-hidden="true" id="chart-summary-visual"></div>
          <div class="sr-only" id="chart-summary-a11y" aria-live="polite"></div>
          <p id="chart-msg" class="small"></p>
          <pre id="chart-debug" class="small" aria-live="polite"></pre>
          <p class="small jp-copy">過去データはAPI仕様・収集失敗で欠損する場合があります。</p>
          <script>
            const tabButtons = document.querySelectorAll('.tabs button');
            const tabSections = document.querySelectorAll('.tab-content');
            tabButtons.forEach(btn => {
              btn.addEventListener('click', () => {
                const target = btn.dataset.tab;
                tabButtons.forEach(b => b.classList.toggle('active', b === btn));
                tabSections.forEach(sec => {
                  sec.style.display = sec.dataset.tab === target ? '' : 'none';
                });
              });
            });
          </script>
          <script>
            (function () {
              const sections = Array.from(document.querySelectorAll('.price-section'));
              if (!sections.length) return;

              const sku = document.body?.dataset?.sku || '';
              const mobileQuery = window.matchMedia('(max-width: 768px)');

              function getScrollerElement() {
                if (document.scrollingElement instanceof HTMLElement) {
                  return document.scrollingElement;
                }
                if (document.documentElement instanceof HTMLElement) {
                  return document.documentElement;
                }
                return null;
              }

              function getScrollY() {
                if (typeof window.scrollY === 'number') {
                  return window.scrollY;
                }
                if (typeof window.pageYOffset === 'number') {
                  return window.pageYOffset;
                }
                const doc = document.documentElement;
                if (doc && typeof doc.scrollTop === 'number') {
                  return doc.scrollTop;
                }
                return 0;
              }

              function restoreOverflowAnchor(element, previous) {
                if (!(element instanceof HTMLElement)) {
                  return;
                }
                if (previous) {
                  element.style.overflowAnchor = previous;
                } else {
                  element.style.removeProperty('overflow-anchor');
                }
              }

              function collapseWithCompensation(button, listElement, toggleFn, options = {}) {
                const anchorOption = options && options.anchor === 'bottom' ? 'bottom' : 'top';
                const toggle = typeof toggleFn === 'function' ? toggleFn : null;
                if (!toggle) {
                  return;
                }

                const scroller = getScrollerElement();
                const list = listElement instanceof HTMLElement ? listElement : null;
                const previousOverflowAnchor = list ? list.style.overflowAnchor || '' : '';
                if (list) {
                  list.style.overflowAnchor = 'none';
                }

                let hasMeasurements = false;
                let beforeTop = 0;
                let beforeDistFromBottom = 0;

                if (button instanceof HTMLElement && scroller) {
                  hasMeasurements = true;
                  const beforeY = getScrollY();
                  const rect = button.getBoundingClientRect();
                  beforeTop = rect.top + beforeY;
                  beforeDistFromBottom = scroller.scrollHeight - (beforeY + window.innerHeight);
                }

                const finalize = () => {
                  if (list) {
                    restoreOverflowAnchor(list, previousOverflowAnchor);
                  }
                };

                try {
                  toggle();
                } finally {
                  if (!hasMeasurements || typeof requestAnimationFrame !== 'function') {
                    finalize();
                    return;
                  }

                  requestAnimationFrame(() => {
                    if (!(button instanceof HTMLElement) || !scroller) {
                      finalize();
                      return;
                    }

                    let delta = 0;
                    if (anchorOption === 'bottom') {
                      const afterY = getScrollY();
                      const afterDistFromBottom = scroller.scrollHeight - (afterY + window.innerHeight);
                      delta = afterDistFromBottom - beforeDistFromBottom;
                    } else {
                      const rect = button.getBoundingClientRect();
                      if (
                        rect.width === 0 &&
                        rect.height === 0 &&
                        typeof window.getComputedStyle === 'function'
                      ) {
                        const display = window.getComputedStyle(button).display;
                        if (!display || display === 'none') {
                          finalize();
                          return;
                        }
                      }

                      const afterTop = rect.top + getScrollY();
                      delta = afterTop - beforeTop;
                    }

                    if (Math.abs(delta) > 0.5) {
                      try {
                        window.scrollBy({ top: delta, behavior: 'instant' });
                      } catch {
                        window.scrollBy(0, delta);
                      }
                    }

                    finalize();
                  });
                }
              }

              const storage = (() => {
                try {
                  const testKey = '__price_sec_test__';
                  window.sessionStorage.setItem(testKey, '1');
                  window.sessionStorage.removeItem(testKey);
                  return window.sessionStorage;
                } catch {
                  return null;
                }
              })();

              function getStorageKey(section) {
                const tab = section?.dataset?.tab || 'all';
                return sku ? `price-sec:${sku}:${tab}` : `price-sec:${tab}`;
              }

              function readState(key) {
                if (!storage || !key) return null;
                try {
                  const value = storage.getItem(key);
                  if (value === '1') return true;
                  if (value === '0') return false;
                } catch {}
                return null;
              }

              function writeState(key, value) {
                if (!storage || !key) return;
                try {
                  storage.setItem(key, value ? '1' : '0');
                } catch {}
              }

              const contexts = sections
                .map(section => {
                  const tbody = section.querySelector('tbody');
                  if (!tbody) return null;
                  const initialRows = Array.from(tbody.querySelectorAll('tr'));
                  if (initialRows.length <= 3) return null;

                  const toggleWrapper = document.createElement('div');
                  toggleWrapper.className = 'list-cta';

                  const expandButton = document.createElement('button');
                  expandButton.type = 'button';
                  expandButton.className = 'table-collapse-toggle';
                  expandButton.dataset.cta = 'expand';
                  expandButton.textContent = 'すべて表示';
                  expandButton.setAttribute('aria-label', 'すべて表示');
                  expandButton.setAttribute('aria-expanded', 'false');

                  const collapseButton = document.createElement('button');
                  collapseButton.type = 'button';
                  collapseButton.className = 'table-collapse-toggle';
                  collapseButton.dataset.cta = 'collapse';
                  collapseButton.dataset.collapseAnchor = 'top';
                  collapseButton.textContent = '折りたたむ';
                  collapseButton.setAttribute('aria-label', '折りたたむ');
                  collapseButton.setAttribute('aria-expanded', 'false');

                  toggleWrapper.appendChild(expandButton);
                  toggleWrapper.appendChild(collapseButton);

                  const toggleRow = document.createElement('tr');
                  toggleRow.className = 'table-collapse-toggle-row';
                  const toggleCell = document.createElement('td');
                  toggleCell.colSpan = initialRows[0]?.children?.length || 1;
                  toggleCell.appendChild(toggleWrapper);
                  toggleCell.setAttribute('data-label', '');
                  toggleRow.appendChild(toggleCell);
                  toggleRow.hidden = true;

                  const key = getStorageKey(section);

                  const table = section.querySelector('table');
                  if (table) {
                    if (!table.id) {
                      const safeId = `price-table-${(key || '')
                        .replace(/[^a-z0-9]+/gi, '-')
                        .replace(/^-+|-+$/g, '') || Math.random().toString(36).slice(2)}`;
                      table.id = safeId;
                    }
                    expandButton.setAttribute('aria-controls', table.id);
                    collapseButton.setAttribute('aria-controls', table.id);
                  }

                  let state = readState(key);
                  if (state == null) {
                    state = false;
                  }

                  let anchorId = table?.id || section.id || '';
                  if (!anchorId) {
                    const generated = `price-section-${(key || '')
                      .replace(/[^a-z0-9]+/gi, '-')
                      .replace(/^-+|-+$/g, '') || Math.random().toString(36).slice(2)}`;
                    section.id = generated;
                    anchorId = generated;
                  }

                  const ctx = {
                    section,
                    tbody,
                    toggleWrapper,
                    expandButton,
                    collapseButton,
                    toggleRow,
                    key,
                    state,
                    observer: null,
                    mutating: false,
                    anchorId,
                  };

                  function handleToggle(nextState) {
                    const isMobile = mobileQuery.matches;
                    ctx.state = nextState;
                    writeState(ctx.key, ctx.state);
                    applyContext(ctx, isMobile);

                    if (isMobile) {
                      const currentAnchor = getCurrentAnchor();
                      const anchorTarget = currentAnchor || ctx.anchorId;
                      if (anchorTarget) {
                        updateAnchor(anchorTarget);
                      }
                    } else if (ctx.state && ctx.anchorId) {
                      updateAnchor(ctx.anchorId);
                    }
                  }

                  expandButton.addEventListener('click', () => {
                    handleToggle(true);
                  });

                  section.addEventListener('click', event => {
                    const target = event.target;
                    if (!(target instanceof Element)) {
                      return;
                    }

                    const collapseTrigger = target.closest(
                      'button.table-collapse-toggle[data-cta="collapse"]'
                    );
                    if (!(collapseTrigger instanceof HTMLButtonElement)) {
                      return;
                    }

                    if (!ctx.state) {
                      return;
                    }

                    const anchorAttr =
                      collapseTrigger.dataset.collapseAnchor
                      || collapseTrigger.getAttribute('data-collapse-anchor')
                      || '';
                    const anchorMode =
                      anchorAttr === 'bottom'
                        ? 'bottom'
                        : anchorAttr === 'top'
                          ? 'top'
                          : collapseTrigger.closest('tr') === ctx.toggleRow
                            ? 'top'
                            : 'bottom';

                    collapseWithCompensation(
                      collapseTrigger,
                      ctx.tbody,
                      () => {
                        handleToggle(false);
                      },
                      { anchor: anchorMode }
                    );
                  });

                  const observer = new MutationObserver(() => {
                    if (ctx.mutating) {
                      return;
                    }
                    if (mobileQuery.matches) {
                      applyContext(ctx, true);
                    }
                  });
                  observer.observe(tbody, { childList: true });
                  ctx.observer = observer;

                  return ctx;
                })
                .filter(Boolean);

              if (!contexts.length) return;

              function getCurrentAnchor() {
                const { location } = window;
                if (!location) return '';
                const { hash } = location;
                if (typeof hash !== 'string' || !hash) return '';
                return hash.replace(/^#+/, '');
              }

              function updateAnchor(anchor) {
                if (!anchor) return;
                const { history, location } = window;
                if (!history || typeof history.replaceState !== 'function' || !location) {
                  return;
                }

                const normalized = anchor.startsWith('#') ? anchor : `#${anchor}`;
                const basePath = `${location.pathname}${location.search || ''}`;
                const nextUrl = `${basePath}${normalized}`;

                try {
                  history.replaceState(history.state, '', nextUrl);
                } catch {}
              }

              function applyContext(ctx, isMobile) {
                const observer = ctx.observer;
                if (observer) {
                  observer.disconnect();
                }

                ctx.mutating = true;
                const rows = Array.from(ctx.tbody.querySelectorAll('tr'));
                const dataRows = rows.filter(row => !row.classList.contains('table-collapse-toggle-row'));

                try {
                  if (!dataRows.length) {
                    ctx.toggleRow.hidden = true;
                    ctx.toggleWrapper.classList.remove('is-expanded');
                    ctx.expandButton.setAttribute('aria-expanded', 'false');
                    ctx.collapseButton.setAttribute('aria-expanded', 'false');
                    return;
                  }

                  const firstDataRow = dataRows[0] || null;
                  const columnCount = firstDataRow?.children?.length || 1;
                  const toggleCell = ctx.toggleRow.firstElementChild;
                  if (toggleCell instanceof HTMLTableCellElement) {
                    toggleCell.colSpan = columnCount;
                  }

                  const shouldToggle = dataRows.length > 3 && isMobile;

                  if (!shouldToggle) {
                    ctx.toggleRow.hidden = true;
                    ctx.toggleWrapper.classList.remove('is-expanded');
                    ctx.expandButton.setAttribute('aria-expanded', 'true');
                    ctx.collapseButton.setAttribute('aria-expanded', 'true');
                    dataRows.forEach(row => {
                      row.hidden = false;
                      row.classList.remove('is-collapsed-row');
                    });
                    return;
                  }

                  const expanded = Boolean(ctx.state);
                  const expandedValue = expanded ? 'true' : 'false';
                  ctx.toggleRow.hidden = false;
                  ctx.toggleWrapper.classList.toggle('is-expanded', expanded);
                  ctx.expandButton.setAttribute('aria-expanded', expandedValue);
                  ctx.collapseButton.setAttribute('aria-expanded', expandedValue);

                  const insertIndex = Math.min(3, dataRows.length);
                  const referenceRow = dataRows[insertIndex] || null;
                  if (referenceRow) {
                    if (ctx.toggleRow.nextElementSibling !== referenceRow) {
                      ctx.tbody.insertBefore(ctx.toggleRow, referenceRow);
                    }
                  } else if (ctx.tbody.lastElementChild !== ctx.toggleRow) {
                    ctx.tbody.appendChild(ctx.toggleRow);
                  }

                  dataRows.forEach((row, index) => {
                    const visible = expanded || index < 3;
                    row.hidden = !visible;
                    row.classList.toggle('is-collapsed-row', !visible);
                  });
                } finally {
                  ctx.mutating = false;
                  if (observer) {
                    observer.observe(ctx.tbody, { childList: true });
                  }
                }
              }

              function applyAll() {
                const isMobile = mobileQuery.matches;
                contexts.forEach(ctx => {
                  const stored = readState(ctx.key);
                  if (stored != null) {
                    ctx.state = stored;
                  }
                  applyContext(ctx, isMobile);
                });
              }

              if (typeof mobileQuery.addEventListener === 'function') {
                mobileQuery.addEventListener('change', applyAll);
              } else if (typeof mobileQuery.addListener === 'function') {
                mobileQuery.addListener(applyAll);
              }
              window.addEventListener('pageshow', applyAll);
              applyAll();
            })();
          </script>
          <script>
            (function () {
              const RANK_LIMIT = 3;

              function getBadgeHosts(row) {
                const hosts = [];
                const headerHost = row.querySelector('.price-card-head .badges');
                if (headerHost) {
                  hosts.push(headerHost);
                }
                const storeCell = row.querySelector('td[data-cell="store"]');
                if (storeCell) {
                  hosts.push(storeCell);
                } else {
                  const shopCell = row.querySelector('td[data-cell="shop"]');
                  if (shopCell) {
                    hosts.push(shopCell);
                  }
                }
                if (!hosts.length) {
                  const fallback = row.querySelector('td');
                  if (fallback) {
                    hosts.push(fallback);
                  }
                }
                return hosts;
              }

              function clearBadge(row) {
                const badges = row.querySelectorAll('.rank-badge');
                badges.forEach(badge => {
                  if (badge.parentElement) {
                    badge.parentElement.removeChild(badge);
                  }
                });
              }

              function applyBadge(row, rank, basisLabel) {
                const hosts = getBadgeHosts(row);
                if (!hosts.length) return;
                const ariaLabel = `ランキング${rank}位（${basisLabel}）`;
                hosts.forEach(host => {
                  let badge = Array.from(host.children || []).find(child =>
                    child.classList && child.classList.contains('rank-badge')
                  );
                  if (!badge) {
                    badge = document.createElement('span');
                    badge.className = 'rank-badge';
                    host.insertBefore(badge, host.firstChild || null);
                  }
                  badge.textContent = `${rank}位`;
                  badge.className = `rank-badge rank-badge--${rank}`;
                  badge.setAttribute('aria-label', ariaLabel);
                  badge.setAttribute('title', ariaLabel);
                });
              }

              function getMetricKey(metric) {
                return metric === 'price' ? 'price' : 'eff';
              }

              function getMetricLabel(metric) {
                return metric === 'price' ? '価格' : '実質価格';
              }

              function updateRankings(section, metric) {
                const tbody = section.querySelector('tbody');
                if (!tbody) return;
                const rows = Array.from(tbody.querySelectorAll('tr')).filter(
                  row => !row.classList.contains('table-collapse-toggle-row')
                );
                const metricKey = getMetricKey(metric);
                const basisLabel = getMetricLabel(metric);
                rows.forEach(clearBadge);
                let processed = 0;
                let currentRank = 0;
                let lastValue = null;
                rows.forEach(row => {
                  processed += 1;
                  const raw = Number(row.dataset[metricKey]);
                  const value = Number.isFinite(raw) ? raw : Number.POSITIVE_INFINITY;
                  if (lastValue === null) {
                    currentRank = 1;
                  } else if (value !== lastValue) {
                    currentRank = processed;
                  }
                  lastValue = value;
                  if (currentRank <= RANK_LIMIT) {
                    applyBadge(row, currentRank, basisLabel);
                  }
                });
              }

              document.querySelectorAll('.price-section').forEach(section => {
                const tbody = section.querySelector('tbody');
                if (!tbody) return;
                const rows = Array.from(tbody.querySelectorAll('tr')).filter(
                  row => !row.classList.contains('table-collapse-toggle-row')
                );
                if (!rows.length) {
                  updateRankings(section, 'eff');
                  return;
                }

                const toggle = section.querySelector('.sort-toggle');
                if (!toggle) {
                  updateRankings(section, 'eff');
                  return;
                }

                let byEff = true;
                function sortRows() {
                  rows
                    .sort((a, b) => {
                      const key = byEff ? 'eff' : 'price';
                      return Number(a.dataset[key]) - Number(b.dataset[key]);
                    })
                    .forEach(r => tbody.appendChild(r));
                }

                function updateToggleLabel() {
                  const labelEff = '実質価格順';
                  const labelPrice = '価格順';
                  const target = byEff ? labelPrice : labelEff;
                  toggle.textContent = `${target}に切替`;
                  toggle.setAttribute('aria-label', `表示を${target}に切り替え`);
                }

                updateToggleLabel();
                sortRows();
                updateRankings(section, byEff ? 'eff' : 'price');

                toggle.addEventListener('click', () => {
                  byEff = !byEff;
                  sortRows();
                  updateToggleLabel();
                  updateRankings(section, byEff ? 'eff' : 'price');
                });
              });
            })();
          </script>
          <script>
            document.addEventListener('DOMContentLoaded', () => {
              const canvas = document.getElementById('chart');
              const msg = document.getElementById('chart-msg');
              const debug = document.getElementById('chart-debug');
              const tooltip = document.getElementById('chart-tooltip');
              const summaryVisual = document.getElementById('chart-summary-visual');
              const summaryA11y = document.getElementById('chart-summary-a11y');
              const chartWrap = canvas?.closest('.chart-wrap') || null;
              const search = typeof window?.location?.search === 'string'
                ? window.location.search
                : '';
              const isDebugMode = search
                ? new URLSearchParams(search).get('dbg') === '1'
                : false;

              if (debug) {
                debug.style.setProperty('display', isDebugMode ? 'block' : '');
              }

              if (!canvas || !msg) {
                if (debug) {
                  debug.textContent = 'chart elements not found';
                }
                return;
              }

              const datasetSku = canvas.dataset?.sku;
              const rawPathname = typeof window?.location?.pathname === 'string'
                ? window.location.pathname
                : '';
              const normalizedPathname = rawPathname.replace(/\/+$/, '');
              const pathnameSku = normalizedPathname.slice(normalizedPathname.lastIndexOf('/') + 1);
              const sku = datasetSku || pathnameSku || '';
              let chartData = null;
              let chartLayout = null;
              let pendingFrame = null;
              let currentDpr = 1;
              let hoverIndex = null;
              let pinnedIndex = null;
              let isPointerDown = false;
              const MAX_RENDER_ATTEMPTS = 3;
              const currencyFormatter = new Intl.NumberFormat('ja-JP', {
                style: 'currency',
                currency: 'JPY',
                maximumFractionDigits: 0,
              });

              function appendDebug(message) {
                if (!debug || !message) return;
                const prefix = sku ? `[${sku}] ` : '[unknown] ';
                const text = `${prefix}${String(message)}`;
                debug.textContent = debug.textContent
                  ? `${debug.textContent}\n${text}`
                  : text;
              }

              function showDebug(message, { temporary = false } = {}) {
                if (!debug) return;
                const prefix = sku ? `[${sku}] ` : '[unknown] ';
                const text = message ? `${prefix}${String(message)}` : '';
                debug.textContent = text;
                if (temporary && text) {
                  setTimeout(() => {
                    if (debug.textContent === text) {
                      debug.textContent = '';
                    }
                  }, 5000);
                }
              }

              function setLoading(isLoading) {
                if (chartWrap) {
                  chartWrap.classList.toggle('is-loading', Boolean(isLoading));
                  chartWrap.classList.toggle('is-loaded', !isLoading);
                }
                if (isLoading) {
                  canvas.setAttribute('aria-busy', 'true');
                } else {
                  canvas.removeAttribute('aria-busy');
                }
              }

              function formatYen(value) {
                const num = Number(value);
                if (!Number.isFinite(num)) {
                  return '';
                }
                return currencyFormatter.format(Math.round(num));
              }

              function parseDate(value) {
                if (!value) return null;
                const date = new Date(value);
                if (Number.isNaN(date.getTime())) return null;
                return date;
              }

              function isSameDay(left, right) {
                return (
                  left.getFullYear() === right.getFullYear()
                  && left.getMonth() === right.getMonth()
                  && left.getDate() === right.getDate()
                );
              }

              function formatDateLabel(value) {
                const date = parseDate(value);
                if (!date) return '';
                return `${date.getMonth() + 1}/${date.getDate()}`;
              }

              function formatSummaryDate(value) {
                const date = parseDate(value);
                if (!date) return '';
                return `${date.getMonth() + 1}/${String(date.getDate()).padStart(2, '0')}`;
              }

              function niceNumber(range, round) {
                if (range <= 0) return 1;
                const exponent = Math.floor(Math.log10(range));
                const fraction = range / 10 ** exponent;
                let niceFraction;
                if (round) {
                  if (fraction < 1.5) niceFraction = 1;
                  else if (fraction < 3) niceFraction = 2;
                  else if (fraction < 7) niceFraction = 5;
                  else niceFraction = 10;
                } else {
                  if (fraction <= 1) niceFraction = 1;
                  else if (fraction <= 2) niceFraction = 2;
                  else if (fraction <= 5) niceFraction = 5;
                  else niceFraction = 10;
                }
                return niceFraction * 10 ** exponent;
              }

              function computeNiceScale(values, tickTarget = 6) {
                if (!values.length) {
                  return {
                    min: 0,
                    max: 1,
                    niceMin: 0,
                    niceMax: 1,
                    step: 1,
                  };
                }
                const min = Math.min(...values);
                const max = Math.max(...values);
                if (min === max) {
                  const padding = Math.max(1, Math.abs(min) * 0.05);
                  return {
                    min,
                    max,
                    niceMin: min - padding,
                    niceMax: max + padding,
                    step: Math.max(1, padding),
                  };
                }
                const range = max - min;
                const niceRange = niceNumber(range, false);
                const step = Math.max(1, niceNumber(niceRange / Math.max(1, tickTarget - 1), true));
                const niceMin = Math.floor(min / step) * step;
                const niceMax = Math.ceil(max / step) * step;
                return { min, max, niceMin, niceMax, step };
              }

              function resolveCssValue(styles, name, fallback, depth = 0) {
                if (depth > 4) {
                  return fallback;
                }
                const raw = styles.getPropertyValue(name);
                if (!raw) {
                  return fallback;
                }
                const value = raw.trim();
                if (!value) {
                  return fallback;
                }
                if (value.startsWith('var(')) {
                  const match = value.match(/^var\(\s*(--[\w-]+)\s*(?:,\s*(.+))?\)$/);
                  if (match) {
                    const [, refName, refFallback] = match;
                    const nextFallback = refFallback ? refFallback.trim() : fallback;
                    return resolveCssValue(styles, refName, nextFallback, depth + 1);
                  }
                }
                if (/^color-mix\(/i.test(value)) {
                  return fallback;
                }
                return value;
              }

              function drawRoundedRectPath(context, x, y, width, height, radius) {
                const r = Math.max(0, Math.min(radius, width / 2, height / 2));
                context.beginPath();
                context.moveTo(x + r, y);
                context.lineTo(x + width - r, y);
                context.quadraticCurveTo(x + width, y, x + width, y + r);
                context.lineTo(x + width, y + height - r);
                context.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
                context.lineTo(x + r, y + height);
                context.quadraticCurveTo(x, y + height, x, y + height - r);
                context.lineTo(x, y + r);
                context.quadraticCurveTo(x, y, x + r, y);
                context.closePath();
              }

              function getDisplayIndex() {
                return pinnedIndex != null ? pinnedIndex : hoverIndex;
              }

              function clearTooltip() {
                if (!tooltip) return;
                tooltip.classList.remove('is-visible');
                tooltip.setAttribute('aria-hidden', 'true');
              }

              function updateTooltip() {
                if (!tooltip || !chartLayout || !chartData || chartData.length < 2) {
                  clearTooltip();
                  return;
                }
                const activeIndex = getDisplayIndex();
                if (activeIndex == null || !chartLayout.points[activeIndex]) {
                  clearTooltip();
                  return;
                }
                const point = chartLayout.points[activeIndex];
                const datum = point.data;
                const dateText = formatDateLabel(datum.date);
                const priceText = formatYen(datum.price);
                tooltip.innerHTML = `
                  <div class="chart-tooltip__date">${dateText}</div>
                  <div class="chart-tooltip__price">${priceText}</div>
                `;
                if (chartWrap && canvas) {
                  const containerRect = chartWrap.getBoundingClientRect();
                  const canvasRect = canvas.getBoundingClientRect();
                  const scaleX = canvasRect.width ? canvasRect.width / canvas.width : 1;
                  const scaleY = canvasRect.height ? canvasRect.height / canvas.height : 1;
                  const left = (canvasRect.left - containerRect.left) + point.x * scaleX;
                  const top = (canvasRect.top - containerRect.top) + point.y * scaleY;
                  tooltip.style.left = `${left}px`;
                  tooltip.style.top = `${top}px`;
                  tooltip.style.setProperty('--shift-x', '0px');
                  tooltip.classList.add('is-visible');
                  tooltip.setAttribute('aria-hidden', 'false');
                  const tooltipRect = tooltip.getBoundingClientRect();
                  let shiftX = 0;
                  if (tooltipRect.left < containerRect.left + 4) {
                    shiftX = containerRect.left + 4 - tooltipRect.left;
                  } else if (tooltipRect.right > containerRect.right - 4) {
                    shiftX = containerRect.right - 4 - tooltipRect.right;
                  }
                  tooltip.style.setProperty('--shift-x', `${shiftX}px`);
                }
                tooltip.dataset.pinned = pinnedIndex != null ? 'true' : 'false';
              }

              function updateSummary() {
                if (!summaryVisual && !summaryA11y) return;
                if (!chartData || chartData.length < 2) {
                  if (summaryVisual) {
                    summaryVisual.innerHTML = '';
                  }
                  if (summaryA11y) {
                    summaryA11y.textContent = 'データが不足しています。';
                  }
                  return;
                }

                const total = chartData.reduce((acc, item) => acc + Number(item.price || 0), 0);
                const avg = total / chartData.length;
                let minItem = chartData[0];
                let maxItem = chartData[0];
                chartData.forEach(item => {
                  if (item.price < minItem.price) minItem = item;
                  if (item.price > maxItem.price) maxItem = item;
                });
                const latest = chartData[chartData.length - 1];
                const periodStart = formatSummaryDate(chartData[0]?.date);
                const periodEnd = formatSummaryDate(chartData[chartData.length - 1]?.date);
                const minDateText = formatSummaryDate(minItem.date);
                const maxDateText = formatSummaryDate(maxItem.date);
                if (summaryVisual) {
                  summaryVisual.innerHTML = '';
                  let periodChip = '';
                  if (periodStart && periodEnd) {
                    periodChip = `期間 ${periodStart}–${periodEnd}`;
                  } else if (periodStart) {
                    periodChip = `期間 ${periodStart}`;
                  } else if (periodEnd) {
                    periodChip = `期間 ${periodEnd}`;
                  }
                  const chipTexts = [
                    periodChip,
                    `最安 ${formatYen(minItem.price)}${minDateText ? ` (${minDateText})` : ''}`,
                    `最高 ${formatYen(maxItem.price)}${maxDateText ? ` (${maxDateText})` : ''}`,
                    `平均 ${formatYen(avg)}`,
                    `最新 ${formatYen(latest.price)}`,
                  ].filter(Boolean);
                  chipTexts.forEach(text => {
                    const chip = document.createElement('span');
                    chip.className = 'chip';
                    chip.textContent = text;
                    summaryVisual.appendChild(chip);
                  });
                }

                if (summaryA11y) {
                  const srParts = [];
                  if (periodStart && periodEnd) {
                    srParts.push(`期間${periodStart}から${periodEnd}。`);
                  } else if (periodStart) {
                    srParts.push(`期間${periodStart}。`);
                  } else if (periodEnd) {
                    srParts.push(`期間${periodEnd}。`);
                  }
                  const statsParts = [
                    `最安${formatYen(minItem.price)}${minDateText ? `（${minDateText}）` : ''}`,
                    `最高${formatYen(maxItem.price)}${maxDateText ? `（${maxDateText}）` : ''}`,
                    `平均${formatYen(avg)}`,
                    `最新${formatYen(latest.price)}`,
                  ];
                  srParts.push(`${statsParts.join('、')}。`);
                  summaryA11y.textContent = srParts.join('');
                }
              }

              function showNoData(reason, currentSku, { hideCanvas = true } = {}) {
                const detail = reason
                  ? `showNoData: ${String(reason)}`
                  : 'showNoData: reason not specified';
                appendDebug(detail);
                if (chartWrap) {
                  setLoading(false);
                }
                clearTooltip();
                chartLayout = null;
                hoverIndex = null;
                pinnedIndex = null;
                if (summaryVisual) {
                  summaryVisual.innerHTML = '';
                }
                if (summaryA11y) {
                  summaryA11y.textContent = 'データが不足しています。';
                }
                canvas.style.display = hideCanvas ? 'none' : '';
                msg.textContent = 'データ少';
                if (reason) {
                  console.warn('showNoData', { reason, sku: currentSku || 'unknown' });
                }
              }

              if (!sku) {
                showNoData('sku not resolved', 'unknown', { hideCanvas: false });
                return;
              }

              function drawChart(dpr) {
                const ctx = canvas.getContext('2d');
                if (!ctx) return;
                const themeStyles = getComputedStyle(chartWrap || document.documentElement);
                const colors = {
                  axis: resolveCssValue(themeStyles, '--chart-axis', 'rgba(100, 116, 139, 0.38)'),
                  grid: resolveCssValue(themeStyles, '--chart-grid', 'rgba(148, 163, 184, 0.16)'),
                  guide: resolveCssValue(themeStyles, '--chart-guide', 'rgba(37, 99, 235, 0.45)'),
                  today: resolveCssValue(themeStyles, '--chart-today', 'rgba(37, 99, 235, 0.28)'),
                  line: resolveCssValue(themeStyles, '--chart-line', '#2563eb'),
                  markerFill: resolveCssValue(themeStyles, '--chart-marker-fill', '#0b0d12'),
                  markerStroke: resolveCssValue(themeStyles, '--chart-marker-stroke', '#2563eb'),
                  text: resolveCssValue(themeStyles, '--chart-text', 'rgba(226, 232, 240, 0.8)'),
                  badgeBg: resolveCssValue(themeStyles, '--chart-badge-bg', 'rgba(15, 23, 42, 0.82)'),
                  badgeFg: resolveCssValue(themeStyles, '--chart-badge-fg', '#f8fafc'),
                };
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const padding = {
                  top: Math.round(12 * dpr),
                  right: Math.round(16 * dpr),
                  bottom: Math.round(36 * dpr),
                  left: Math.round(64 * dpr),
                };
                const width = canvas.width;
                const height = canvas.height;
                const innerWidth = Math.max(1, width - padding.left - padding.right);
                const innerHeight = Math.max(1, height - padding.top - padding.bottom);
                const prices = chartData.map(d => d.price);
                const { niceMin, niceMax, step } = computeNiceScale(prices);
                const yRange = niceMax - niceMin || 1;
                const yTicks = [];
                for (let value = niceMin; value <= niceMax + step / 2; value += step) {
                  yTicks.push(value);
                }
                const cssWidth = canvas.clientWidth || canvas.width / dpr;
                const isCompactWidth = cssWidth < 420;
                const desiredXTicks = isCompactWidth ? 4 : 6;
                const minLabelGapCss = isCompactWidth ? 56 : 72;
                const labelPaddingCss = 4;
                const fontSize = 12 * dpr;
                ctx.fillStyle = colors.text;
                ctx.font = `${fontSize}px "system-ui", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;

                const formatMonthDay = date => `${date.getMonth() + 1}/${date.getDate()}`;
                const formatDay = date => String(date.getDate());
                const isSameMonth = (a, b) =>
                  Boolean(a && b && a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth());

                const lastDatum = chartData[chartData.length - 1];
                let badgeAvoidRightCss = 0;
                if (lastDatum) {
                  const lastDate = parseDate(lastDatum.date);
                  const now = new Date();
                  const isToday =
                    lastDate
                    && now.getFullYear() === lastDate.getFullYear()
                    && now.getMonth() === lastDate.getMonth()
                    && now.getDate() === lastDate.getDate();
                  const badgeLabel = `${isToday ? '本日' : '最新'} ${formatYen(lastDatum.price)}`;
                  const badgeWidthCss = ctx.measureText(badgeLabel).width / dpr;
                  const markerRadiusCss = 5;
                  badgeAvoidRightCss = Math.max(0, badgeWidthCss + 8 + markerRadiusCss);
                }

                const plotLeft = padding.left;
                const plotRight = Math.max(plotLeft, width - padding.right);
                const plotLeftCss = plotLeft / dpr;
                const plotRightCss = plotRight / dpr;
                const innerPlotRightCss = Math.max(plotLeftCss, plotRightCss - badgeAvoidRightCss);

                const indexToCssX = index => {
                  const ratio = chartData.length > 1 ? index / (chartData.length - 1) : 0;
                  const x = padding.left + ratio * innerWidth;
                  return x / dpr;
                };

                const labels = [];
                const firstIndex = 0;
                const lastIndex = chartData.length - 1;
                const firstDate = chartData.length ? parseDate(chartData[firstIndex].date) : null;
                const lastDate = chartData.length ? parseDate(chartData[lastIndex].date) : null;
                if (firstDate) {
                  labels.push({
                    index: firstIndex,
                    xCss: indexToCssX(firstIndex),
                    text: formatMonthDay(firstDate),
                    date: firstDate,
                  });
                }
                if (lastDate && lastIndex !== firstIndex) {
                  labels.push({
                    index: lastIndex,
                    xCss: indexToCssX(lastIndex),
                    text: formatMonthDay(lastDate),
                    date: lastDate,
                  });
                }

                const candidateCount = Math.min(chartData.length, Math.max(desiredXTicks + 1, 2));
                const candidateIndexes = new Set();
                for (let i = 0; i < candidateCount; i += 1) {
                  const ratio = candidateCount > 1 ? i / (candidateCount - 1) : 0;
                  const index = Math.round(ratio * (chartData.length - 1));
                  candidateIndexes.add(Math.min(chartData.length - 1, Math.max(0, index)));
                }

                const innerCandidates = Array.from(candidateIndexes).filter(
                  index => index !== firstIndex && index !== lastIndex,
                );

                const rightmostLabel = labels.reduce((acc, label) => {
                  if (!label) return acc;
                  if (!acc || label.xCss > acc.xCss) {
                    return label;
                  }
                  return acc;
                }, null);
                let lastPlacedXCss = rightmostLabel ? rightmostLabel.xCss : Number.POSITIVE_INFINITY;
                let nextPlacedDate = rightmostLabel ? rightmostLabel.date : null;
                if (!rightmostLabel || rightmostLabel.index !== lastIndex) {
                  lastPlacedXCss = Number.POSITIVE_INFINITY;
                  nextPlacedDate = null;
                }
                innerCandidates
                  .sort((a, b) => b - a)
                  .forEach(index => {
                    const candidate = chartData[index];
                    if (!candidate) {
                      return;
                    }
                    const date = parseDate(candidate.date);
                    if (!date) {
                      return;
                    }
                    const xCss = indexToCssX(index);
                    if (xCss < plotLeftCss || xCss > plotRightCss) {
                      return;
                    }
                    if (xCss > innerPlotRightCss) {
                      return;
                    }
                    const text =
                      nextPlacedDate && isSameMonth(date, nextPlacedDate)
                        ? formatDay(date)
                        : formatMonthDay(date);
                    const textWidthCss = ctx.measureText(text).width / dpr;
                    if (textWidthCss <= 0) {
                      return;
                    }
                    const minGap = Math.max(minLabelGapCss, textWidthCss / 2 + labelPaddingCss);
                    if (lastPlacedXCss - xCss < minGap) {
                      return;
                    }
                    labels.push({ index, xCss, text, date });
                    lastPlacedXCss = xCss;
                    nextPlacedDate = date;
                  });

                labels.sort((a, b) => a.xCss - b.xCss);
                if (labels.length) {
                  const firstLabel = labels[0];
                  const firstWidthCss = ctx.measureText(firstLabel.text).width / dpr;
                  if (firstLabel.xCss - firstWidthCss / 2 < plotLeftCss) {
                    firstLabel.drawOffsetCss = plotLeftCss + firstWidthCss / 2 - firstLabel.xCss;
                  }
                }

                const xTicks = labels
                  .sort((a, b) => a.index - b.index)
                  .map(label => ({
                    index: label.index,
                    x: (label.xCss + (label.drawOffsetCss || 0)) * dpr,
                    label: label.text,
                  }));
                ctx.save();
                ctx.lineWidth = Math.max(1, dpr);
                ctx.strokeStyle = colors.axis;
                ctx.beginPath();
                ctx.moveTo(padding.left, height - padding.bottom);
                ctx.lineTo(width - padding.right, height - padding.bottom);
                ctx.moveTo(padding.left, padding.top);
                ctx.lineTo(padding.left, height - padding.bottom);
                ctx.stroke();
                ctx.restore();

                ctx.save();
                ctx.setLineDash([4 * dpr, 6 * dpr]);
                ctx.lineWidth = Math.max(1, dpr);
                ctx.strokeStyle = colors.grid;
                yTicks.forEach(value => {
                  const y = padding.top + (1 - (value - niceMin) / yRange) * innerHeight;
                  ctx.beginPath();
                  ctx.moveTo(padding.left, y);
                  ctx.lineTo(width - padding.right, y);
                  ctx.stroke();
                });
                ctx.restore();

                ctx.textBaseline = 'middle';
                ctx.textAlign = 'right';
                yTicks.forEach(value => {
                  const y = padding.top + (1 - (value - niceMin) / yRange) * innerHeight;
                  ctx.fillText(formatYen(value), padding.left - 8 * dpr, y);
                });

                ctx.textBaseline = 'top';
                ctx.textAlign = 'center';
                xTicks.forEach(tick => {
                  ctx.fillText(tick.label, tick.x, height - padding.bottom + 8 * dpr);
                });

                const points = chartData.map((datum, index) => {
                  const ratio = chartData.length > 1 ? index / (chartData.length - 1) : 0;
                  const x = padding.left + ratio * innerWidth;
                  const y = padding.top + (1 - (datum.price - niceMin) / yRange) * innerHeight;
                  return { x, y, data: datum };
                });

                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const todayIndex = points.findIndex(point => {
                  const pointDate = parseDate(point.data.date);
                  return pointDate ? isSameDay(pointDate, today) : false;
                });
                if (todayIndex >= 0 && points[todayIndex]) {
                  const todayPoint = points[todayIndex];
                  ctx.save();
                  ctx.setLineDash([2 * dpr, 6 * dpr]);
                  ctx.strokeStyle = colors.today;
                  ctx.lineWidth = Math.max(1, dpr);
                  ctx.beginPath();
                  ctx.moveTo(todayPoint.x, padding.top);
                  ctx.lineTo(todayPoint.x, height - padding.bottom);
                  ctx.stroke();
                  ctx.restore();
                }

                ctx.save();
                ctx.strokeStyle = colors.line;
                ctx.lineWidth = Math.max(1, 2 * dpr);
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.beginPath();
                points.forEach((point, index) => {
                  if (index === 0) {
                    ctx.moveTo(point.x, point.y);
                  } else {
                    ctx.lineTo(point.x, point.y);
                  }
                });
                ctx.stroke();
                ctx.restore();

                const activeIndex = getDisplayIndex();
                if (activeIndex != null && points[activeIndex]) {
                  const activePoint = points[activeIndex];
                  ctx.save();
                  ctx.setLineDash([3 * dpr, 6 * dpr]);
                  ctx.strokeStyle = colors.guide;
                  ctx.lineWidth = Math.max(1, dpr);
                  ctx.beginPath();
                  ctx.moveTo(activePoint.x, padding.top);
                  ctx.lineTo(activePoint.x, height - padding.bottom);
                  ctx.stroke();
                  ctx.restore();
                }

                const markerIndexes = new Set();
                if (points.length) {
                  markerIndexes.add(points.length - 1);
                }
                if (activeIndex != null && points[activeIndex]) {
                  markerIndexes.add(activeIndex);
                }
                markerIndexes.forEach(index => {
                  const point = points[index];
                  if (!point) return;
                  const isActive = index === activeIndex;
                  const radius = isActive ? 5 * dpr : 3.5 * dpr;
                  const strokeWidth = isActive ? Math.max(1.5 * dpr, 1.5) : Math.max(1, dpr);
                  ctx.save();
                  ctx.fillStyle = colors.markerFill;
                  ctx.strokeStyle = colors.markerStroke;
                  ctx.lineWidth = strokeWidth;
                  ctx.beginPath();
                  ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
                  ctx.fill();
                  ctx.stroke();
                  ctx.restore();
                });

                const lastPoint = points[points.length - 1];
                if (lastPoint) {
                  const lastDatum = lastPoint.data;
                  const lastDate = parseDate(lastDatum.date);
                  const now = new Date();
                  const isToday = lastDate
                    && now.getFullYear() === lastDate.getFullYear()
                    && now.getMonth() === lastDate.getMonth()
                    && now.getDate() === lastDate.getDate();
                  const badgeLabel = `${isToday ? '本日' : '最新'} ${formatYen(lastDatum.price)}`;
                  const badgePaddingX = 8 * dpr;
                  const badgePaddingY = 4 * dpr;
                  ctx.font = `${12 * dpr}px "system-ui", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
                  const textWidth = ctx.measureText(badgeLabel).width;
                  const badgeWidth = textWidth + badgePaddingX * 2;
                  const badgeHeight = 20 * dpr;
                  const badgeX = Math.min(width - padding.right - badgeWidth, lastPoint.x + 8 * dpr);
                  const badgeY = Math.max(padding.top, lastPoint.y - badgeHeight - 8 * dpr);
                  ctx.fillStyle = colors.badgeBg;
                  drawRoundedRectPath(ctx, badgeX, badgeY, badgeWidth, badgeHeight, 6 * dpr);
                  ctx.fill();
                  ctx.fillStyle = colors.badgeFg;
                  ctx.textAlign = 'left';
                  ctx.textBaseline = 'middle';
                  ctx.fillText(badgeLabel, badgeX + badgePaddingX, badgeY + badgeHeight / 2);
                }

                chartLayout = {
                  padding,
                  innerWidth,
                  innerHeight,
                  points,
                  niceMin,
                  niceMax,
                };
                msg.textContent = '';
              }

              function renderChart(currentSku, attempt = 0) {
                if (!chartData || chartData.length < 2) return;
                if (pendingFrame !== null) {
                  cancelAnimationFrame(pendingFrame);
                }
                pendingFrame = requestAnimationFrame(() => {
                  pendingFrame = null;
                  const clientWidth = canvas.clientWidth;
                  const offsetWidth = canvas.offsetWidth;
                  appendDebug(
                    `render attempt ${attempt + 1}: clientWidth=${clientWidth} offsetWidth=${offsetWidth}`,
                  );
                  const cssWidth = canvas.clientWidth || canvas.offsetWidth;
                  if (!cssWidth) {
                    if (attempt + 1 < MAX_RENDER_ATTEMPTS) {
                      renderChart(currentSku, attempt + 1);
                    } else {
                      showNoData('zero-size canvas', currentSku, { hideCanvas: false });
                    }
                    return;
                  }
                  const cssHeight = Math.max(160, Math.round(cssWidth * 0.4));
                  canvas.style.height = `${cssHeight}px`;
                  const dpr = Math.min(window.devicePixelRatio || 1, 2);
                  canvas.width = Math.floor(cssWidth * dpr);
                  canvas.height = Math.floor(cssHeight * dpr);
                  appendDebug(
                    `render attempt ${attempt + 1}: canvas.width=${canvas.width} canvas.height=${canvas.height} dpr=${dpr}`,
                  );
                  if (!canvas.width || !canvas.height) {
                    if (attempt + 1 < MAX_RENDER_ATTEMPTS) {
                      renderChart(currentSku, attempt + 1);
                    } else {
                      showNoData('zero-size canvas', currentSku, { hideCanvas: false });
                    }
                    return;
                  }
                  if (window.__APP_DEV__) {
                    console.log('chart canvas dimensions', {
                      cssWidth,
                      cssHeight,
                      canvasWidth: canvas.width,
                      canvasHeight: canvas.height,
                      dpr,
                    });
                  }
                  currentDpr = dpr;
                  drawChart(dpr);
                  updateTooltip();
                });
              }

              const resizeTarget = canvas.parentElement || canvas;
              if ('ResizeObserver' in window && resizeTarget) {
                const observer = new ResizeObserver(() => {
                  if (!chartData || chartData.length < 2) return;
                  renderChart(sku);
                });
                observer.observe(resizeTarget);
              } else {
                const handleResize = () => {
                  if (!chartData || chartData.length < 2) return;
                  renderChart(sku);
                };
                window.addEventListener('resize', handleResize);
                window.addEventListener('orientationchange', handleResize);
              }

              function getNearestIndex(deviceX) {
                if (!chartLayout || !chartLayout.points || !chartLayout.points.length) {
                  return null;
                }
                let nearest = 0;
                let minDistance = Number.POSITIVE_INFINITY;
                chartLayout.points.forEach((point, index) => {
                  const distance = Math.abs(point.x - deviceX);
                  if (distance < minDistance) {
                    minDistance = distance;
                    nearest = index;
                  }
                });
                return nearest;
              }

              function refreshVisualState() {
                if (!chartData || chartData.length < 2) {
                  clearTooltip();
                  return;
                }
                drawChart(currentDpr);
                updateTooltip();
              }

              if (canvas) {
                canvas.addEventListener('pointerdown', event => {
                  if (!chartLayout || !chartData || chartData.length < 2) return;
                  isPointerDown = true;
                  const rect = canvas.getBoundingClientRect();
                  const scale = canvas.width / rect.width;
                  const deviceX = (event.clientX - rect.left) * scale;
                  const index = getNearestIndex(deviceX);
                  if (typeof canvas.focus === 'function') {
                    try {
                      canvas.focus({ preventScroll: true });
                    } catch {
                      canvas.focus();
                    }
                  }
                  if (pinnedIndex === index) {
                    pinnedIndex = null;
                    hoverIndex = null;
                    refreshVisualState();
                    return;
                  }
                  pinnedIndex = index;
                  hoverIndex = index;
                  refreshVisualState();
                });
                canvas.addEventListener('pointerup', () => {
                  isPointerDown = false;
                });
                canvas.addEventListener('pointercancel', () => {
                  isPointerDown = false;
                });
                canvas.addEventListener('pointerleave', () => {
                  isPointerDown = false;
                  if (pinnedIndex == null) {
                    hoverIndex = null;
                    clearTooltip();
                    drawChart(currentDpr);
                  }
                });
                canvas.addEventListener('pointermove', event => {
                  if (!chartLayout || !chartData || chartData.length < 2) return;
                  if (pinnedIndex != null && !isPointerDown) {
                    return;
                  }
                  const rect = canvas.getBoundingClientRect();
                  const scale = canvas.width / rect.width;
                  const deviceX = (event.clientX - rect.left) * scale;
                  const index = getNearestIndex(deviceX);
                  if (index !== hoverIndex) {
                    hoverIndex = index;
                    if (pinnedIndex == null || isPointerDown) {
                      refreshVisualState();
                    } else {
                      updateTooltip();
                    }
                  } else if (pinnedIndex == null) {
                    updateTooltip();
                  }
                });
                canvas.addEventListener('focus', () => {
                  if (!chartData || chartData.length < 2) return;
                  if (pinnedIndex == null && hoverIndex == null) {
                    pinnedIndex = chartData.length - 1;
                    hoverIndex = pinnedIndex;
                    refreshVisualState();
                  }
                });
                canvas.addEventListener('keydown', event => {
                  if (!chartData || chartData.length < 2) return;
                  if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                    event.preventDefault();
                    const direction = event.key === 'ArrowLeft' ? -1 : 1;
                    const baseIndex = getDisplayIndex() != null ? getDisplayIndex() : (direction > 0 ? 0 : chartData.length - 1);
                    let nextIndex = baseIndex + direction;
                    nextIndex = Math.max(0, Math.min(chartData.length - 1, nextIndex));
                    pinnedIndex = nextIndex;
                    hoverIndex = nextIndex;
                    refreshVisualState();
                  }
                });
              }

              document.addEventListener('pointerdown', event => {
                if (!canvas) return;
                if (!chartWrap) return;
                if (!chartWrap.contains(event.target)) {
                  pinnedIndex = null;
                  hoverIndex = null;
                  if (!chartData || chartData.length < 2) {
                    clearTooltip();
                  } else {
                    refreshVisualState();
                  }
                }
              });

              async function loadChart(currentSku) {
                try {
                  const url = new URL(
                    `data/price-history/${currentSku}.json?t=${Date.now()}`,
                    document.baseURI,
                  );
                  showDebug(url.toString());
                  if (chartWrap) {
                    setLoading(true);
                  }
                  canvas.style.display = 'none';
                  msg.textContent = '読み込み中…';
                  clearTooltip();
                  const res = await fetch(url);
                  if (!res.ok) {
                    const message = `HTTP ${res.status} ${url.toString()}`;
                    console.error(message);
                    showDebug(message);
                    showNoData(message, currentSku);
                    return;
                  }
                  const hist = await res.json();
                  const list = Array.isArray(hist) ? hist : Object.values(hist).find(Array.isArray) || [];
                  const filtered = list
                    .map(item => {
                      const price = Number(item?.price);
                      const date = item?.date;
                      if (!Number.isFinite(price) || !date) {
                        return null;
                      }
                      return { date, price };
                    })
                    .filter(Boolean)
                    .sort((a, b) => {
                      const left = parseDate(a.date)?.getTime() ?? 0;
                      const right = parseDate(b.date)?.getTime() ?? 0;
                      return left - right;
                    })
                    .slice(-30);
                  if (filtered.length < 2) {
                    showNoData(`insufficient data (n=${filtered.length})`, currentSku);
                    return;
                  }
                  chartData = filtered;
                  canvas.style.display = '';
                  msg.textContent = '';
                  if (chartWrap) {
                    setLoading(false);
                  }
                  updateSummary();
                  showDebug(url.toString());
                  renderChart(currentSku);
                } catch (err) {
                  console.error(err);
                  const errorMessage = err instanceof Error ? err.message : String(err);
                  showNoData(errorMessage, currentSku);
                  if (window.__APP_DEV__) {
                    const error = err instanceof Error ? err : new Error(String(err));
                    const stackLine = typeof error.stack === 'string' ? error.stack.split('\n')[1]?.trim() : '';
                    const info = stackLine ? `${error.message} @ ${stackLine}` : error.message;
                    showDebug(info, { temporary: true });
                  }
                }
              }

              loadChart(sku);
            });
          </script>
        </>
      ) : (
        <p>データ少</p>
      )}
    </div>
    <Footer />
  </body>
</html>
