---
import "../../styles/global.css";
import Footer from "../../components/Footer.astro";
import skus from "../../data/skus.json";
import { safeBreak } from "../../lib/safe-break";
const IS_DEV = import.meta.env.DEV;
const BASE_URL = import.meta.env.BASE_URL;
const clientGlobalsScript = `window.__APP_DEV__ = ${JSON.stringify(IS_DEV)};\nwindow.__BASE_URL__ = ${JSON.stringify(BASE_URL)};`;

let data;
let rakutenData;
let yahooData;
try {
  const url = new URL(
    BASE_URL + "data/prices/today.json",
    Astro.site
  );
  const res = await fetch(url);
  if (res.ok) {
    data = await res.json();
  }
} catch {}
try {
  const url = new URL(
    BASE_URL + "data/prices/today.rakuten.json",
    Astro.site
  );
  const res = await fetch(url);
  if (res.ok) {
    rakutenData = await res.json();
  }
} catch {}
try {
  const url = new URL(
    BASE_URL + "data/prices/today.yahoo.json",
    Astro.site
  );
  const res = await fetch(url);
  if (res.ok) {
    yahooData = await res.json();
  }
} catch {}
const { sku } = Astro.params;
const skuInfo = skus.find(s => s.id === sku);
const priceInfo = data?.items?.find(i => i.skuId === sku);
function getEffectivePriceValue(it) {
  const price = Number(it?.price);
  if (!Number.isFinite(price)) {
    return Number.POSITIVE_INFINITY;
  }
  const pointRate = Number(it?.pointRate ?? 0);
  if (!Number.isFinite(pointRate) || pointRate <= 0) {
    return Math.floor(price);
  }
  return Math.floor(price * (100 - pointRate) / 100);
}

function withEffectivePrice(it) {
  return {
    ...it,
    effective: getEffectivePriceValue(it)
  };
}

const list = priceInfo?.list ? priceInfo.list.map(withEffectivePrice).sort((a, b) => a.effective - b.effective) : [];
const rakutenSource = rakutenData?.items?.find(i => i.skuId === sku)?.list ?? [];
const yahooSource = yahooData?.items?.find(i => i.skuId === sku)?.list ?? [];
const rakutenList = rakutenSource.map(withEffectivePrice).sort((a, b) => a.effective - b.effective);
const yahooList = yahooSource.map(withEffectivePrice).sort((a, b) => a.effective - b.effective);
const allList = [
  ...rakutenList.map(it => ({ ...it, store: '楽天' })),
  ...yahooList.map(it => ({ ...it, store: 'Yahoo' }))
].sort((a, b) => a.effective - b.effective);
const hasAllPoints = allList.some(it => Number(it.pointRate) > 0);
const sections = [
  { name: '楽天', key: 'rakuten', list: rakutenList, status: data?.sourceStatus?.rakuten ?? 'fail', hasPoints: rakutenList.some(it => Number(it.pointRate) > 0) },
  { name: 'Yahoo', key: 'yahoo', list: yahooList, status: data?.sourceStatus?.yahoo ?? 'fail', hasPoints: yahooList.some(it => Number(it.pointRate) > 0) }
];
const statusMessages = {
  partial: 'このソースの一部データが取得できませんでした。表示は最新の取得分です。',
  fail: 'このソースの取得に失敗しました。別ソースまたは前回データで表示しています。'
};
const bestToday = allList.length
  ? allList[0]
  : (list.length ? list.reduce((min, it) => (it.effective < min.effective ? it : min), list[0]) : null);
let bestRecommended = priceInfo?.bestRecommended ?? null;
if (!bestRecommended && list.length && skuInfo?.brandHints?.length) {
  const cand = list.filter(it => {
    const title = it.title?.toLowerCase() ?? '';
    return skuInfo.brandHints.some(b => title.includes(b.toLowerCase()));
  });
  if (cand.length) {
    bestRecommended = cand.reduce((min, it) => (it.effective < min.effective ? it : min), cand[0]);
  }
}
if (bestRecommended) {
  bestRecommended = { ...bestRecommended, effective: Number.isFinite(bestRecommended.effective) ? bestRecommended.effective : getEffectivePriceValue(bestRecommended) };
}
const bestTodayCard = getPriceCardModel(bestToday, { prefix: '最安' });
const bestRecommendedCard = getPriceCardModel(bestRecommended, { prefix: '推奨' });
function formatCurrency(value) {
  const num = Number(value);
  if (!Number.isFinite(num)) return '';
  return `${Math.round(num).toLocaleString('ja-JP')}円`;
}

function formatPrice(it) {
  if (!it) return '';
  return formatCurrency(it.price);
}

function getShopLinkDescription(name) {
  if (!name) {
    return 'ショップで商品の詳細を確認できます（新しいタブで開きます）';
  }
  return `${name}で商品の詳細を確認できます（新しいタブで開きます）`;
}

function truncateShopName(name, maxLength = 20) {
  if (!name) return '';
  if (name.length <= maxLength) {
    return name;
  }
  return `${name.slice(0, maxLength)}…`;
}

function getPriceCardModel(item, { prefix }) {
  if (!item) return null;
  const rawPrice = Number(item.price);
  if (!Number.isFinite(rawPrice) || rawPrice <= 0) {
    return null;
  }

  const effectiveValue = Number.isFinite(item.effective) ? item.effective : getEffectivePriceValue(item);
  const pointRate = Number(item.pointRate ?? 0);
  const priceText = formatCurrency(rawPrice);
  const hasEffectiveLine = Number.isFinite(effectiveValue) && effectiveValue > 0 && effectiveValue !== rawPrice;
  const effectiveText = hasEffectiveLine ? formatCurrency(effectiveValue) : null;

  const resolvedName = item.shopName ?? '';
  const displayNameSource = resolvedName || 'ショップ';

  return {
    hasEffectiveLine,
    prefix,
    primaryValue: hasEffectiveLine ? effectiveText : priceText,
    primaryAriaLabel: hasEffectiveLine ? `実質価格 ${effectiveText}` : `通常価格 ${priceText}`,
    secondaryPrice: priceText,
    secondaryPriceAriaLabel: `通常価格 ${priceText}`,
    hasPoints: hasEffectiveLine && pointRate > 0,
    pointRateText: `${pointRate}%`,
    pointRateAriaLabel: `ポイント還元率 ${pointRate}%`,
    shopName: resolvedName,
    shopDisplayName: truncateShopName(displayNameSource),
    shopTitle: resolvedName || undefined,
    itemUrl: item.itemUrl
  };
}

function getStoreBadgeClass(store) {
  if (store === '楽天') {
    return 'store-badge store-badge--rakuten';
  }
  if (typeof store === 'string' && store.toLowerCase() === 'yahoo') {
    return 'store-badge store-badge--yahoo';
  }
  return 'store-badge';
}

export function getStaticPaths() {
  return skus.map(s => ({ params: { sku: s.id } }));
}
---
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <base href={BASE_URL} />
    <script is:inline set:html={clientGlobalsScript}></script>
    <title>{skuInfo ? skuInfo.q : sku} – 価格一覧</title>
  </head>
  <body>
    <div class="wrap">
        <a href="./" class="small">← トップ</a>
      <h1 set:html={safeBreak(`${skuInfo ? skuInfo.q : sku} – 価格一覧`)}></h1>
      <p class="jp-copy">ショップ別の価格を一覧しています。並び順は <span class="nobr">目安（価格）です。</span></p>
      <p class="small jp-copy">
        {data
          ? `取得日時: ${new Date(data.updatedAt).toLocaleString('ja-JP')}`
          : 'データ少'}
      </p>
      {skuInfo && (
        <div>
          <h2 set:html={safeBreak("仕様")}></h2>
          <ul>
            {skuInfo.filters && <li>フィルタ: {skuInfo.filters.join(', ')}</li>}
            {skuInfo.brandHints && <li>ブランド候補: {skuInfo.brandHints.join(', ')}</li>}
          </ul>
        </div>
      )}
      {priceInfo ? (
        <>
          <div class="best-price">
            <h2 set:html={safeBreak("最安情報")}></h2>
            <div class="best-price-cards">
              <section class="best-price-card" role="region" aria-labelledby="best-today-heading">
                <p class="best-price-card__label" id="best-today-heading">今日の最安</p>
                {bestTodayCard ? (
                  <>
                    <p class="best-price-card__line best-price-card__line--primary">
                      <span class="best-price-card__value" aria-label={bestTodayCard.primaryAriaLabel}>{bestTodayCard.primaryValue}</span>
                    </p>
                    {bestTodayCard.hasEffectiveLine && (
                      <p class="best-price-card__line best-price-card__line--secondary">
                        <span aria-label={bestTodayCard.secondaryPriceAriaLabel}>通常 {bestTodayCard.secondaryPrice}</span>
                        {bestTodayCard.hasPoints && (
                          <>
                            <span aria-hidden="true"> / </span>
                            <span aria-label={bestTodayCard.pointRateAriaLabel}>ポイント {bestTodayCard.pointRateText}</span>
                          </>
                        )}
                      </p>
                    )}
                    {bestTodayCard.itemUrl && (
                      <p class="best-price-card__line best-price-card__line--link">
                        <a
                          href={bestTodayCard.itemUrl}
                          target="_blank"
                          rel="nofollow noopener"
                          class="best-price-card__link"
                          title={bestTodayCard.shopTitle}
                          aria-label={getShopLinkDescription(bestTodayCard.shopName || bestTodayCard.shopDisplayName)}
                        >
                          {bestTodayCard.shopDisplayName} で確認 <span aria-hidden="true">↗</span>
                        </a>
                      </p>
                    )}
                  </>
                ) : (
                  <p class="best-price-card__line best-price-card__line--empty">データ少</p>
                )}
              </section>
              {skuInfo?.brandHints?.length ? (
                <section class="best-price-card" role="region" aria-labelledby="best-recommended-heading">
                  <p class="best-price-card__label" id="best-recommended-heading">推奨最安（ブランド一致）</p>
                  {bestRecommendedCard ? (
                    <>
                      <p class="best-price-card__line best-price-card__line--primary">
                        <span class="best-price-card__value" aria-label={bestRecommendedCard.primaryAriaLabel}>{bestRecommendedCard.primaryValue}</span>
                      </p>
                      {bestRecommendedCard.hasEffectiveLine && (
                        <p class="best-price-card__line best-price-card__line--secondary">
                          <span aria-label={bestRecommendedCard.secondaryPriceAriaLabel}>通常 {bestRecommendedCard.secondaryPrice}</span>
                          {bestRecommendedCard.hasPoints && (
                            <>
                              <span aria-hidden="true"> / </span>
                              <span aria-label={bestRecommendedCard.pointRateAriaLabel}>ポイント {bestRecommendedCard.pointRateText}</span>
                            </>
                          )}
                        </p>
                      )}
                      {bestRecommendedCard.itemUrl && (
                        <p class="best-price-card__line best-price-card__line--link">
                          <a
                            href={bestRecommendedCard.itemUrl}
                            target="_blank"
                            rel="nofollow noopener"
                            class="best-price-card__link"
                            title={bestRecommendedCard.shopTitle}
                            aria-label={getShopLinkDescription(bestRecommendedCard.shopName || bestRecommendedCard.shopDisplayName)}
                          >
                            {bestRecommendedCard.shopDisplayName} で確認 <span aria-hidden="true">↗</span>
                          </a>
                        </p>
                      )}
                    </>
                  ) : (
                    <p class="best-price-card__line best-price-card__line--empty">該当なし</p>
                  )}
                </section>
              ) : null}
            </div>
          </div>
          <div class="tabs">
            <button type="button" data-tab="all" class="active">全ストア</button>
            <button type="button" data-tab="rakuten">楽天のみ</button>
            <button type="button" data-tab="yahoo">Yahooのみ</button>
          </div>
          <div class="price-section tab-content" data-tab="all">
            <h2 class="sr-only" set:html={safeBreak("全ストア")}></h2>
            {allList.length ? (
              <>
                {hasAllPoints && <button class="sort-toggle">価格順に切替</button>}
                <table class="price-table">
                  <thead class="sr-only">
                    <tr>
                      <th id="col-all-store" scope="col">ストア</th>
                      <th id="col-all-shop" scope="col">ショップ</th>
                      <th id="col-all-price" scope="col" data-column="price">価格</th>
                      <th id="col-all-point" scope="col" data-column="points">ポイント</th>
                      <th id="col-all-eff" scope="col" data-column="effective">実質価格<br/><span class="small">（ポイント込み）</span></th>
                      <th id="col-all-action" scope="col" data-column="action" class="sr-only">ショップで確認</th>
                    </tr>
                  </thead>
                  <tbody>
                    {allList.map(it => {
                      const eff = Number.isFinite(it.effective) ? it.effective : getEffectivePriceValue(it);
                      const hasPointRate = Number(it.pointRate ?? 0) > 0;
                      return (
                        <tr class="has-store-badge" data-price={it.price} data-eff={eff}>
                          <td
                            headers="col-all-store"
                            data-label="ストア"
                            data-cell="store"
                          >
                            <span class={getStoreBadgeClass(it.store)}>{it.store}</span>
                          </td>
                          <td headers="col-all-shop" data-label="ショップ" data-cell="shop">
                            <span class="shop-name" title={it.shopName}>
                              {it.shopName}
                            </span>
                          </td>
                          <td
                            headers="col-all-price"
                            data-label="価格"
                            data-cell="price"
                            class={!hasPointRate ? 'is-muted' : undefined}
                          >
                            {formatPrice(it)}
                          </td>
                          <td headers="col-all-point" data-label="ポイント" data-cell="points">{hasPointRate ? `${it.pointRate}%` : '-'}</td>
                          <td headers="col-all-eff" data-label="実質価格" data-cell="effective">{formatCurrency(eff)}</td>
                          <td
                            headers="col-all-action"
                            data-label="ショップで確認"
                            data-cell="action"
                          >
                            <a
                              class="shop-link-button"
                              href={it.itemUrl}
                              target="_blank"
                              rel="nofollow noopener"
                              title={getShopLinkDescription(it.shopName)}
                              aria-label={getShopLinkDescription(it.shopName)}
                            >
                              ショップで確認
                              <span aria-hidden="true" class="external-link-icon">↗</span>
                            </a>
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </>
            ) : (
              <p>データ少</p>
            )}
          </div>
          {sections.map(sec => (
            <div class="price-section tab-content" data-tab={sec.key} data-source-status={sec.status} style="display:none">
              <h2 class="sr-only" set:html={safeBreak(sec.name)}></h2>
              {sec.status !== 'ok' && (
                <span class="status-icon--warn" aria-label={statusMessages[sec.status]} title={statusMessages[sec.status]}>⚠️</span>
              )}
              {sec.list.length ? (
              <>
                  {sec.hasPoints && <button class="sort-toggle">価格順に切替</button>}
                  <table class="price-table">
                    <thead class="sr-only">
                      <tr>
                        <th id={`col-${sec.key}-shop`} scope="col">ショップ</th>
                        <th id={`col-${sec.key}-price`} scope="col" data-column="price">価格</th>
                        <th id={`col-${sec.key}-point`} scope="col" data-column="points">ポイント</th>
                        <th id={`col-${sec.key}-eff`} scope="col" data-column="effective">実質価格<br/><span class="small">（ポイント込み）</span></th>
                        <th id={`col-${sec.key}-action`} scope="col" data-column="action" class="sr-only">ショップで確認</th>
                      </tr>
                    </thead>
                    <tbody>
                      {sec.list.map(it => {
                        const eff = Number.isFinite(it.effective) ? it.effective : getEffectivePriceValue(it);
                        const hasPointRate = Number(it.pointRate ?? 0) > 0;
                        return (
                          <tr data-price={it.price} data-eff={eff}>
                            <td headers={`col-${sec.key}-shop`} data-label="ショップ" data-cell="shop">
                              <span class="shop-name" title={it.shopName}>
                                {it.shopName}
                              </span>
                            </td>
                            <td
                              headers={`col-${sec.key}-price`}
                              data-label="価格"
                              data-cell="price"
                              class={!hasPointRate ? 'is-muted' : undefined}
                            >
                              {formatPrice(it)}
                            </td>
                            <td headers={`col-${sec.key}-point`} data-label="ポイント" data-cell="points">{hasPointRate ? `${it.pointRate}%` : '-'}</td>
                            <td headers={`col-${sec.key}-eff`} data-label="実質価格" data-cell="effective">{formatCurrency(eff)}</td>
                            <td
                              headers={`col-${sec.key}-action`}
                              data-label="ショップで確認"
                              data-cell="action"
                            >
                              <a
                                class="shop-link-button"
                                href={it.itemUrl}
                                target="_blank"
                                rel="nofollow noopener"
                                title={getShopLinkDescription(it.shopName)}
                                aria-label={getShopLinkDescription(it.shopName)}
                              >
                                ショップで確認
                                <span aria-hidden="true" class="external-link-icon">↗</span>
                              </a>
                            </td>
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                </>
              ) : (
                <p>データ少</p>
              )}
            </div>
          ))}
          <p class="small jp-copy">※実質価格はポイント考慮の試算です。</p>
          <p class="small jp-copy">価格・在庫は常に変動します。購入前にリンク先で最新情報をご確認ください。</p>
          <h2 set:html={safeBreak("価格推移 (30日)")}></h2>
          <div class="chart-container chart-wrap">
            <div id="chart-skeleton" class="chart-skeleton" aria-hidden="true"></div>
            <canvas
              id="chart"
              class="chart"
              data-sku={sku}
              tabindex="0"
              aria-label="過去30日の価格推移。左右キーでポイントを移動できます。"
            ></canvas>
            <div id="chart-tooltip" class="chart-tooltip" role="presentation" aria-hidden="true"></div>
          </div>
          <div class="chart-summary chips" aria-hidden="true" id="chart-summary-visual"></div>
          <div class="sr-only" id="chart-summary-a11y" aria-live="polite"></div>
          <p id="chart-msg" class="small"></p>
          <pre id="chart-debug" class="small" aria-live="polite"></pre>
          <p class="small jp-copy">過去データはAPI仕様・収集失敗で欠損する場合があります。</p>
          <script>
            const tabButtons = document.querySelectorAll('.tabs button');
            const tabSections = document.querySelectorAll('.tab-content');
            tabButtons.forEach(btn => {
              btn.addEventListener('click', () => {
                const target = btn.dataset.tab;
                tabButtons.forEach(b => b.classList.toggle('active', b === btn));
                tabSections.forEach(sec => {
                  sec.style.display = sec.dataset.tab === target ? '' : 'none';
                });
              });
            });
          </script>
          <script>
            document.querySelectorAll('.price-section').forEach(sec => {
              const toggle = sec.querySelector('.sort-toggle');
              const tbody = sec.querySelector('tbody');
              if (!toggle || !tbody) return;
              const rows = Array.from(tbody.querySelectorAll('tr'));
              let byEff = true;
              function sortRows() {
                rows
                  .sort((a, b) => {
                    const k = byEff ? 'eff' : 'price';
                    return Number(a.dataset[k]) - Number(b.dataset[k]);
                  })
                  .forEach(r => tbody.appendChild(r));
              }
              function updateLabel() {
                toggle.textContent = byEff ? '価格順に切替' : '実質価格順に切替';
              }
              updateLabel();
              sortRows();
              toggle.addEventListener('click', () => {
                byEff = !byEff;
                sortRows();
                updateLabel();
              });
            });
          </script>
          <script>
            document.addEventListener('DOMContentLoaded', () => {
              const canvas = document.getElementById('chart');
              const msg = document.getElementById('chart-msg');
              const debug = document.getElementById('chart-debug');
              const tooltip = document.getElementById('chart-tooltip');
              const summaryVisual = document.getElementById('chart-summary-visual');
              const summaryA11y = document.getElementById('chart-summary-a11y');
              const chartWrap = canvas?.closest('.chart-wrap') || null;
              const search = typeof window?.location?.search === 'string'
                ? window.location.search
                : '';
              const isDebugMode = search
                ? new URLSearchParams(search).get('dbg') === '1'
                : false;

              if (debug) {
                debug.style.setProperty('display', isDebugMode ? 'block' : '');
              }

              if (!canvas || !msg) {
                if (debug) {
                  debug.textContent = 'chart elements not found';
                }
                return;
              }

              const datasetSku = canvas.dataset?.sku;
              const rawPathname = typeof window?.location?.pathname === 'string'
                ? window.location.pathname
                : '';
              const normalizedPathname = rawPathname.replace(/\/+$/, '');
              const pathnameSku = normalizedPathname.slice(normalizedPathname.lastIndexOf('/') + 1);
              const sku = datasetSku || pathnameSku || '';
              let chartData = null;
              let chartLayout = null;
              let pendingFrame = null;
              let currentDpr = 1;
              let hoverIndex = null;
              let pinnedIndex = null;
              let isPointerDown = false;
              const MAX_RENDER_ATTEMPTS = 3;
              const currencyFormatter = new Intl.NumberFormat('ja-JP', {
                style: 'currency',
                currency: 'JPY',
                maximumFractionDigits: 0,
              });

              function appendDebug(message) {
                if (!debug || !message) return;
                const prefix = sku ? `[${sku}] ` : '[unknown] ';
                const text = `${prefix}${String(message)}`;
                debug.textContent = debug.textContent
                  ? `${debug.textContent}\n${text}`
                  : text;
              }

              function showDebug(message, { temporary = false } = {}) {
                if (!debug) return;
                const prefix = sku ? `[${sku}] ` : '[unknown] ';
                const text = message ? `${prefix}${String(message)}` : '';
                debug.textContent = text;
                if (temporary && text) {
                  setTimeout(() => {
                    if (debug.textContent === text) {
                      debug.textContent = '';
                    }
                  }, 5000);
                }
              }

              function setLoading(isLoading) {
                if (chartWrap) {
                  chartWrap.classList.toggle('is-loading', Boolean(isLoading));
                  chartWrap.classList.toggle('is-loaded', !isLoading);
                }
                if (isLoading) {
                  canvas.setAttribute('aria-busy', 'true');
                } else {
                  canvas.removeAttribute('aria-busy');
                }
              }

              function formatYen(value) {
                const num = Number(value);
                if (!Number.isFinite(num)) {
                  return '';
                }
                return currencyFormatter.format(Math.round(num));
              }

              function parseDate(value) {
                if (!value) return null;
                const date = new Date(value);
                if (Number.isNaN(date.getTime())) return null;
                return date;
              }

              function isSameDay(left, right) {
                return (
                  left.getFullYear() === right.getFullYear()
                  && left.getMonth() === right.getMonth()
                  && left.getDate() === right.getDate()
                );
              }

              function formatDateLabel(value) {
                const date = parseDate(value);
                if (!date) return '';
                return `${date.getMonth() + 1}/${date.getDate()}`;
              }

              function formatSummaryDate(value) {
                const date = parseDate(value);
                if (!date) return '';
                return `${date.getMonth() + 1}/${String(date.getDate()).padStart(2, '0')}`;
              }

              function niceNumber(range, round) {
                if (range <= 0) return 1;
                const exponent = Math.floor(Math.log10(range));
                const fraction = range / 10 ** exponent;
                let niceFraction;
                if (round) {
                  if (fraction < 1.5) niceFraction = 1;
                  else if (fraction < 3) niceFraction = 2;
                  else if (fraction < 7) niceFraction = 5;
                  else niceFraction = 10;
                } else {
                  if (fraction <= 1) niceFraction = 1;
                  else if (fraction <= 2) niceFraction = 2;
                  else if (fraction <= 5) niceFraction = 5;
                  else niceFraction = 10;
                }
                return niceFraction * 10 ** exponent;
              }

              function computeNiceScale(values, tickTarget = 6) {
                if (!values.length) {
                  return {
                    min: 0,
                    max: 1,
                    niceMin: 0,
                    niceMax: 1,
                    step: 1,
                  };
                }
                const min = Math.min(...values);
                const max = Math.max(...values);
                if (min === max) {
                  const padding = Math.max(1, Math.abs(min) * 0.05);
                  return {
                    min,
                    max,
                    niceMin: min - padding,
                    niceMax: max + padding,
                    step: Math.max(1, padding),
                  };
                }
                const range = max - min;
                const niceRange = niceNumber(range, false);
                const step = Math.max(1, niceNumber(niceRange / Math.max(1, tickTarget - 1), true));
                const niceMin = Math.floor(min / step) * step;
                const niceMax = Math.ceil(max / step) * step;
                return { min, max, niceMin, niceMax, step };
              }

              function resolveCssValue(styles, name, fallback, depth = 0) {
                if (depth > 4) {
                  return fallback;
                }
                const raw = styles.getPropertyValue(name);
                if (!raw) {
                  return fallback;
                }
                const value = raw.trim();
                if (!value) {
                  return fallback;
                }
                if (value.startsWith('var(')) {
                  const match = value.match(/^var\(\s*(--[\w-]+)\s*(?:,\s*(.+))?\)$/);
                  if (match) {
                    const [, refName, refFallback] = match;
                    const nextFallback = refFallback ? refFallback.trim() : fallback;
                    return resolveCssValue(styles, refName, nextFallback, depth + 1);
                  }
                }
                if (/^color-mix\(/i.test(value)) {
                  return fallback;
                }
                return value;
              }

              function drawRoundedRectPath(context, x, y, width, height, radius) {
                const r = Math.max(0, Math.min(radius, width / 2, height / 2));
                context.beginPath();
                context.moveTo(x + r, y);
                context.lineTo(x + width - r, y);
                context.quadraticCurveTo(x + width, y, x + width, y + r);
                context.lineTo(x + width, y + height - r);
                context.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
                context.lineTo(x + r, y + height);
                context.quadraticCurveTo(x, y + height, x, y + height - r);
                context.lineTo(x, y + r);
                context.quadraticCurveTo(x, y, x + r, y);
                context.closePath();
              }

              function getDisplayIndex() {
                return pinnedIndex != null ? pinnedIndex : hoverIndex;
              }

              function clearTooltip() {
                if (!tooltip) return;
                tooltip.classList.remove('is-visible');
                tooltip.setAttribute('aria-hidden', 'true');
              }

              function updateTooltip() {
                if (!tooltip || !chartLayout || !chartData || chartData.length < 2) {
                  clearTooltip();
                  return;
                }
                const activeIndex = getDisplayIndex();
                if (activeIndex == null || !chartLayout.points[activeIndex]) {
                  clearTooltip();
                  return;
                }
                const point = chartLayout.points[activeIndex];
                const datum = point.data;
                const dateText = formatDateLabel(datum.date);
                const priceText = formatYen(datum.price);
                tooltip.innerHTML = `
                  <div class="chart-tooltip__date">${dateText}</div>
                  <div class="chart-tooltip__price">${priceText}</div>
                `;
                if (chartWrap && canvas) {
                  const containerRect = chartWrap.getBoundingClientRect();
                  const canvasRect = canvas.getBoundingClientRect();
                  const scaleX = canvasRect.width ? canvasRect.width / canvas.width : 1;
                  const scaleY = canvasRect.height ? canvasRect.height / canvas.height : 1;
                  const left = (canvasRect.left - containerRect.left) + point.x * scaleX;
                  const top = (canvasRect.top - containerRect.top) + point.y * scaleY;
                  tooltip.style.left = `${left}px`;
                  tooltip.style.top = `${top}px`;
                  tooltip.style.setProperty('--shift-x', '0px');
                  tooltip.classList.add('is-visible');
                  tooltip.setAttribute('aria-hidden', 'false');
                  const tooltipRect = tooltip.getBoundingClientRect();
                  let shiftX = 0;
                  if (tooltipRect.left < containerRect.left + 4) {
                    shiftX = containerRect.left + 4 - tooltipRect.left;
                  } else if (tooltipRect.right > containerRect.right - 4) {
                    shiftX = containerRect.right - 4 - tooltipRect.right;
                  }
                  tooltip.style.setProperty('--shift-x', `${shiftX}px`);
                }
                tooltip.dataset.pinned = pinnedIndex != null ? 'true' : 'false';
              }

              function updateSummary() {
                if (!summaryVisual && !summaryA11y) return;
                if (!chartData || chartData.length < 2) {
                  if (summaryVisual) {
                    summaryVisual.innerHTML = '';
                  }
                  if (summaryA11y) {
                    summaryA11y.textContent = 'データが不足しています。';
                  }
                  return;
                }

                const total = chartData.reduce((acc, item) => acc + Number(item.price || 0), 0);
                const avg = total / chartData.length;
                let minItem = chartData[0];
                let maxItem = chartData[0];
                chartData.forEach(item => {
                  if (item.price < minItem.price) minItem = item;
                  if (item.price > maxItem.price) maxItem = item;
                });
                const latest = chartData[chartData.length - 1];
                const periodStart = formatSummaryDate(chartData[0]?.date);
                const periodEnd = formatSummaryDate(chartData[chartData.length - 1]?.date);
                const minDateText = formatSummaryDate(minItem.date);
                const maxDateText = formatSummaryDate(maxItem.date);
                if (summaryVisual) {
                  summaryVisual.innerHTML = '';
                  let periodChip = '';
                  if (periodStart && periodEnd) {
                    periodChip = `期間 ${periodStart}–${periodEnd}`;
                  } else if (periodStart) {
                    periodChip = `期間 ${periodStart}`;
                  } else if (periodEnd) {
                    periodChip = `期間 ${periodEnd}`;
                  }
                  const chipTexts = [
                    periodChip,
                    `最安 ${formatYen(minItem.price)}${minDateText ? ` (${minDateText})` : ''}`,
                    `最高 ${formatYen(maxItem.price)}${maxDateText ? ` (${maxDateText})` : ''}`,
                    `平均 ${formatYen(avg)}`,
                    `最新 ${formatYen(latest.price)}`,
                  ].filter(Boolean);
                  chipTexts.forEach(text => {
                    const chip = document.createElement('span');
                    chip.className = 'chip';
                    chip.textContent = text;
                    summaryVisual.appendChild(chip);
                  });
                }

                if (summaryA11y) {
                  const srParts = [];
                  if (periodStart && periodEnd) {
                    srParts.push(`期間${periodStart}から${periodEnd}。`);
                  } else if (periodStart) {
                    srParts.push(`期間${periodStart}。`);
                  } else if (periodEnd) {
                    srParts.push(`期間${periodEnd}。`);
                  }
                  const statsParts = [
                    `最安${formatYen(minItem.price)}${minDateText ? `（${minDateText}）` : ''}`,
                    `最高${formatYen(maxItem.price)}${maxDateText ? `（${maxDateText}）` : ''}`,
                    `平均${formatYen(avg)}`,
                    `最新${formatYen(latest.price)}`,
                  ];
                  srParts.push(`${statsParts.join('、')}。`);
                  summaryA11y.textContent = srParts.join('');
                }
              }

              function showNoData(reason, currentSku, { hideCanvas = true } = {}) {
                const detail = reason
                  ? `showNoData: ${String(reason)}`
                  : 'showNoData: reason not specified';
                appendDebug(detail);
                if (chartWrap) {
                  setLoading(false);
                }
                clearTooltip();
                chartLayout = null;
                hoverIndex = null;
                pinnedIndex = null;
                if (summaryVisual) {
                  summaryVisual.innerHTML = '';
                }
                if (summaryA11y) {
                  summaryA11y.textContent = 'データが不足しています。';
                }
                canvas.style.display = hideCanvas ? 'none' : '';
                msg.textContent = 'データ少';
                if (reason) {
                  console.warn('showNoData', { reason, sku: currentSku || 'unknown' });
                }
              }

              if (!sku) {
                showNoData('sku not resolved', 'unknown', { hideCanvas: false });
                return;
              }

              function drawChart(dpr) {
                const ctx = canvas.getContext('2d');
                if (!ctx) return;
                const themeStyles = getComputedStyle(chartWrap || document.documentElement);
                const colors = {
                  axis: resolveCssValue(themeStyles, '--chart-axis', 'rgba(100, 116, 139, 0.38)'),
                  grid: resolveCssValue(themeStyles, '--chart-grid', 'rgba(148, 163, 184, 0.16)'),
                  guide: resolveCssValue(themeStyles, '--chart-guide', 'rgba(37, 99, 235, 0.45)'),
                  today: resolveCssValue(themeStyles, '--chart-today', 'rgba(37, 99, 235, 0.28)'),
                  line: resolveCssValue(themeStyles, '--chart-line', '#2563eb'),
                  markerFill: resolveCssValue(themeStyles, '--chart-marker-fill', '#0b0d12'),
                  markerStroke: resolveCssValue(themeStyles, '--chart-marker-stroke', '#2563eb'),
                  text: resolveCssValue(themeStyles, '--chart-text', 'rgba(226, 232, 240, 0.8)'),
                  badgeBg: resolveCssValue(themeStyles, '--chart-badge-bg', 'rgba(15, 23, 42, 0.82)'),
                  badgeFg: resolveCssValue(themeStyles, '--chart-badge-fg', '#f8fafc'),
                };
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const padding = {
                  top: Math.round(12 * dpr),
                  right: Math.round(16 * dpr),
                  bottom: Math.round(36 * dpr),
                  left: Math.round(64 * dpr),
                };
                const width = canvas.width;
                const height = canvas.height;
                const innerWidth = Math.max(1, width - padding.left - padding.right);
                const innerHeight = Math.max(1, height - padding.top - padding.bottom);
                const prices = chartData.map(d => d.price);
                const { niceMin, niceMax, step } = computeNiceScale(prices);
                const yRange = niceMax - niceMin || 1;
                const yTicks = [];
                for (let value = niceMin; value <= niceMax + step / 2; value += step) {
                  yTicks.push(value);
                }
                const xTicks = [];
                const desiredXTicks = 6;
                const stepCount = Math.max(1, Math.ceil((chartData.length - 1) / Math.max(1, desiredXTicks - 1)));
                for (let i = 0; i < chartData.length; i += stepCount) {
                  xTicks.push(i);
                }
                if (xTicks[xTicks.length - 1] !== chartData.length - 1) {
                  xTicks.push(chartData.length - 1);
                }
                ctx.save();
                ctx.lineWidth = Math.max(1, dpr);
                ctx.strokeStyle = colors.axis;
                ctx.beginPath();
                ctx.moveTo(padding.left, height - padding.bottom);
                ctx.lineTo(width - padding.right, height - padding.bottom);
                ctx.moveTo(padding.left, padding.top);
                ctx.lineTo(padding.left, height - padding.bottom);
                ctx.stroke();
                ctx.restore();

                ctx.save();
                ctx.setLineDash([4 * dpr, 6 * dpr]);
                ctx.lineWidth = Math.max(1, dpr);
                ctx.strokeStyle = colors.grid;
                yTicks.forEach(value => {
                  const y = padding.top + (1 - (value - niceMin) / yRange) * innerHeight;
                  ctx.beginPath();
                  ctx.moveTo(padding.left, y);
                  ctx.lineTo(width - padding.right, y);
                  ctx.stroke();
                });
                ctx.restore();

                const fontSize = 12 * dpr;
                ctx.fillStyle = colors.text;
                ctx.font = `${fontSize}px "system-ui", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'right';
                yTicks.forEach(value => {
                  const y = padding.top + (1 - (value - niceMin) / yRange) * innerHeight;
                  ctx.fillText(formatYen(value), padding.left - 8 * dpr, y);
                });

                ctx.textBaseline = 'top';
                ctx.textAlign = 'center';
                xTicks.forEach(index => {
                  const ratio = chartData.length > 1 ? index / (chartData.length - 1) : 0;
                  const x = padding.left + ratio * innerWidth;
                  ctx.fillText(formatDateLabel(chartData[index].date), x, height - padding.bottom + 8 * dpr);
                });

                const points = chartData.map((datum, index) => {
                  const ratio = chartData.length > 1 ? index / (chartData.length - 1) : 0;
                  const x = padding.left + ratio * innerWidth;
                  const y = padding.top + (1 - (datum.price - niceMin) / yRange) * innerHeight;
                  return { x, y, data: datum };
                });

                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const todayIndex = points.findIndex(point => {
                  const pointDate = parseDate(point.data.date);
                  return pointDate ? isSameDay(pointDate, today) : false;
                });
                if (todayIndex >= 0 && points[todayIndex]) {
                  const todayPoint = points[todayIndex];
                  ctx.save();
                  ctx.setLineDash([2 * dpr, 6 * dpr]);
                  ctx.strokeStyle = colors.today;
                  ctx.lineWidth = Math.max(1, dpr);
                  ctx.beginPath();
                  ctx.moveTo(todayPoint.x, padding.top);
                  ctx.lineTo(todayPoint.x, height - padding.bottom);
                  ctx.stroke();
                  ctx.restore();
                }

                ctx.save();
                ctx.strokeStyle = colors.line;
                ctx.lineWidth = Math.max(1, 2 * dpr);
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.beginPath();
                points.forEach((point, index) => {
                  if (index === 0) {
                    ctx.moveTo(point.x, point.y);
                  } else {
                    ctx.lineTo(point.x, point.y);
                  }
                });
                ctx.stroke();
                ctx.restore();

                const activeIndex = getDisplayIndex();
                if (activeIndex != null && points[activeIndex]) {
                  const activePoint = points[activeIndex];
                  ctx.save();
                  ctx.setLineDash([3 * dpr, 6 * dpr]);
                  ctx.strokeStyle = colors.guide;
                  ctx.lineWidth = Math.max(1, dpr);
                  ctx.beginPath();
                  ctx.moveTo(activePoint.x, padding.top);
                  ctx.lineTo(activePoint.x, height - padding.bottom);
                  ctx.stroke();
                  ctx.restore();
                }

                const markerIndexes = new Set();
                if (points.length) {
                  markerIndexes.add(points.length - 1);
                }
                if (activeIndex != null && points[activeIndex]) {
                  markerIndexes.add(activeIndex);
                }
                markerIndexes.forEach(index => {
                  const point = points[index];
                  if (!point) return;
                  const isActive = index === activeIndex;
                  const radius = isActive ? 5 * dpr : 3.5 * dpr;
                  const strokeWidth = isActive ? Math.max(1.5 * dpr, 1.5) : Math.max(1, dpr);
                  ctx.save();
                  ctx.fillStyle = colors.markerFill;
                  ctx.strokeStyle = colors.markerStroke;
                  ctx.lineWidth = strokeWidth;
                  ctx.beginPath();
                  ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
                  ctx.fill();
                  ctx.stroke();
                  ctx.restore();
                });

                const lastPoint = points[points.length - 1];
                if (lastPoint) {
                  const lastDatum = lastPoint.data;
                  const lastDate = parseDate(lastDatum.date);
                  const now = new Date();
                  const isToday = lastDate
                    && now.getFullYear() === lastDate.getFullYear()
                    && now.getMonth() === lastDate.getMonth()
                    && now.getDate() === lastDate.getDate();
                  const badgeLabel = `${isToday ? '本日' : '最新'} ${formatYen(lastDatum.price)}`;
                  const badgePaddingX = 8 * dpr;
                  const badgePaddingY = 4 * dpr;
                  ctx.font = `${12 * dpr}px "system-ui", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
                  const textWidth = ctx.measureText(badgeLabel).width;
                  const badgeWidth = textWidth + badgePaddingX * 2;
                  const badgeHeight = 20 * dpr;
                  const badgeX = Math.min(width - padding.right - badgeWidth, lastPoint.x + 8 * dpr);
                  const badgeY = Math.max(padding.top, lastPoint.y - badgeHeight - 8 * dpr);
                  ctx.fillStyle = colors.badgeBg;
                  drawRoundedRectPath(ctx, badgeX, badgeY, badgeWidth, badgeHeight, 6 * dpr);
                  ctx.fill();
                  ctx.fillStyle = colors.badgeFg;
                  ctx.textAlign = 'left';
                  ctx.textBaseline = 'middle';
                  ctx.fillText(badgeLabel, badgeX + badgePaddingX, badgeY + badgeHeight / 2);
                }

                chartLayout = {
                  padding,
                  innerWidth,
                  innerHeight,
                  points,
                  niceMin,
                  niceMax,
                };
                msg.textContent = '';
              }

              function renderChart(currentSku, attempt = 0) {
                if (!chartData || chartData.length < 2) return;
                if (pendingFrame !== null) {
                  cancelAnimationFrame(pendingFrame);
                }
                pendingFrame = requestAnimationFrame(() => {
                  pendingFrame = null;
                  const clientWidth = canvas.clientWidth;
                  const offsetWidth = canvas.offsetWidth;
                  appendDebug(
                    `render attempt ${attempt + 1}: clientWidth=${clientWidth} offsetWidth=${offsetWidth}`,
                  );
                  const cssWidth = canvas.clientWidth || canvas.offsetWidth;
                  if (!cssWidth) {
                    if (attempt + 1 < MAX_RENDER_ATTEMPTS) {
                      renderChart(currentSku, attempt + 1);
                    } else {
                      showNoData('zero-size canvas', currentSku, { hideCanvas: false });
                    }
                    return;
                  }
                  const cssHeight = Math.max(160, Math.round(cssWidth * 0.4));
                  canvas.style.height = `${cssHeight}px`;
                  const dpr = Math.min(window.devicePixelRatio || 1, 2);
                  canvas.width = Math.floor(cssWidth * dpr);
                  canvas.height = Math.floor(cssHeight * dpr);
                  appendDebug(
                    `render attempt ${attempt + 1}: canvas.width=${canvas.width} canvas.height=${canvas.height} dpr=${dpr}`,
                  );
                  if (!canvas.width || !canvas.height) {
                    if (attempt + 1 < MAX_RENDER_ATTEMPTS) {
                      renderChart(currentSku, attempt + 1);
                    } else {
                      showNoData('zero-size canvas', currentSku, { hideCanvas: false });
                    }
                    return;
                  }
                  if (window.__APP_DEV__) {
                    console.log('chart canvas dimensions', {
                      cssWidth,
                      cssHeight,
                      canvasWidth: canvas.width,
                      canvasHeight: canvas.height,
                      dpr,
                    });
                  }
                  currentDpr = dpr;
                  drawChart(dpr);
                  updateTooltip();
                });
              }

              const resizeTarget = canvas.parentElement || canvas;
              if ('ResizeObserver' in window && resizeTarget) {
                const observer = new ResizeObserver(() => {
                  if (!chartData || chartData.length < 2) return;
                  renderChart(sku);
                });
                observer.observe(resizeTarget);
              } else {
                const handleResize = () => {
                  if (!chartData || chartData.length < 2) return;
                  renderChart(sku);
                };
                window.addEventListener('resize', handleResize);
                window.addEventListener('orientationchange', handleResize);
              }

              function getNearestIndex(deviceX) {
                if (!chartLayout || !chartLayout.points || !chartLayout.points.length) {
                  return null;
                }
                let nearest = 0;
                let minDistance = Number.POSITIVE_INFINITY;
                chartLayout.points.forEach((point, index) => {
                  const distance = Math.abs(point.x - deviceX);
                  if (distance < minDistance) {
                    minDistance = distance;
                    nearest = index;
                  }
                });
                return nearest;
              }

              function refreshVisualState() {
                if (!chartData || chartData.length < 2) {
                  clearTooltip();
                  return;
                }
                drawChart(currentDpr);
                updateTooltip();
              }

              if (canvas) {
                canvas.addEventListener('pointerdown', event => {
                  if (!chartLayout || !chartData || chartData.length < 2) return;
                  isPointerDown = true;
                  const rect = canvas.getBoundingClientRect();
                  const scale = canvas.width / rect.width;
                  const deviceX = (event.clientX - rect.left) * scale;
                  const index = getNearestIndex(deviceX);
                  if (typeof canvas.focus === 'function') {
                    try {
                      canvas.focus({ preventScroll: true });
                    } catch {
                      canvas.focus();
                    }
                  }
                  if (pinnedIndex === index) {
                    pinnedIndex = null;
                    hoverIndex = null;
                    refreshVisualState();
                    return;
                  }
                  pinnedIndex = index;
                  hoverIndex = index;
                  refreshVisualState();
                });
                canvas.addEventListener('pointerup', () => {
                  isPointerDown = false;
                });
                canvas.addEventListener('pointercancel', () => {
                  isPointerDown = false;
                });
                canvas.addEventListener('pointerleave', () => {
                  isPointerDown = false;
                  if (pinnedIndex == null) {
                    hoverIndex = null;
                    clearTooltip();
                    drawChart(currentDpr);
                  }
                });
                canvas.addEventListener('pointermove', event => {
                  if (!chartLayout || !chartData || chartData.length < 2) return;
                  if (pinnedIndex != null && !isPointerDown) {
                    return;
                  }
                  const rect = canvas.getBoundingClientRect();
                  const scale = canvas.width / rect.width;
                  const deviceX = (event.clientX - rect.left) * scale;
                  const index = getNearestIndex(deviceX);
                  if (index !== hoverIndex) {
                    hoverIndex = index;
                    if (pinnedIndex == null || isPointerDown) {
                      refreshVisualState();
                    } else {
                      updateTooltip();
                    }
                  } else if (pinnedIndex == null) {
                    updateTooltip();
                  }
                });
                canvas.addEventListener('focus', () => {
                  if (!chartData || chartData.length < 2) return;
                  if (pinnedIndex == null && hoverIndex == null) {
                    pinnedIndex = chartData.length - 1;
                    hoverIndex = pinnedIndex;
                    refreshVisualState();
                  }
                });
                canvas.addEventListener('keydown', event => {
                  if (!chartData || chartData.length < 2) return;
                  if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                    event.preventDefault();
                    const direction = event.key === 'ArrowLeft' ? -1 : 1;
                    const baseIndex = getDisplayIndex() != null ? getDisplayIndex() : (direction > 0 ? 0 : chartData.length - 1);
                    let nextIndex = baseIndex + direction;
                    nextIndex = Math.max(0, Math.min(chartData.length - 1, nextIndex));
                    pinnedIndex = nextIndex;
                    hoverIndex = nextIndex;
                    refreshVisualState();
                  }
                });
              }

              document.addEventListener('pointerdown', event => {
                if (!canvas) return;
                if (!chartWrap) return;
                if (!chartWrap.contains(event.target)) {
                  pinnedIndex = null;
                  hoverIndex = null;
                  if (!chartData || chartData.length < 2) {
                    clearTooltip();
                  } else {
                    refreshVisualState();
                  }
                }
              });

              async function loadChart(currentSku) {
                try {
                  const url = new URL(
                    `data/price-history/${currentSku}.json?t=${Date.now()}`,
                    document.baseURI,
                  );
                  showDebug(url.toString());
                  if (chartWrap) {
                    setLoading(true);
                  }
                  canvas.style.display = 'none';
                  msg.textContent = '読み込み中…';
                  clearTooltip();
                  const res = await fetch(url);
                  if (!res.ok) {
                    const message = `HTTP ${res.status} ${url.toString()}`;
                    console.error(message);
                    showDebug(message);
                    showNoData(message, currentSku);
                    return;
                  }
                  const hist = await res.json();
                  const list = Array.isArray(hist) ? hist : Object.values(hist).find(Array.isArray) || [];
                  const filtered = list
                    .map(item => {
                      const price = Number(item?.price);
                      const date = item?.date;
                      if (!Number.isFinite(price) || !date) {
                        return null;
                      }
                      return { date, price };
                    })
                    .filter(Boolean)
                    .sort((a, b) => {
                      const left = parseDate(a.date)?.getTime() ?? 0;
                      const right = parseDate(b.date)?.getTime() ?? 0;
                      return left - right;
                    })
                    .slice(-30);
                  if (filtered.length < 2) {
                    showNoData(`insufficient data (n=${filtered.length})`, currentSku);
                    return;
                  }
                  chartData = filtered;
                  canvas.style.display = '';
                  msg.textContent = '';
                  if (chartWrap) {
                    setLoading(false);
                  }
                  updateSummary();
                  showDebug(url.toString());
                  renderChart(currentSku);
                } catch (err) {
                  console.error(err);
                  const errorMessage = err instanceof Error ? err.message : String(err);
                  showNoData(errorMessage, currentSku);
                  if (window.__APP_DEV__) {
                    const error = err instanceof Error ? err : new Error(String(err));
                    const stackLine = typeof error.stack === 'string' ? error.stack.split('\n')[1]?.trim() : '';
                    const info = stackLine ? `${error.message} @ ${stackLine}` : error.message;
                    showDebug(info, { temporary: true });
                  }
                }
              }

              loadChart(sku);
            });
          </script>
        </>
      ) : (
        <p>データ少</p>
      )}
    </div>
    <Footer />
  </body>
</html>
